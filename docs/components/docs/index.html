<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <meta name="google-site-verification" content="qjqVOvRhHfsuDbLOvaAnj2mkUZJ9Xwzg84TMVXduvUc" />

    <meta charset="UTF-8">
    <title>Hyperloop</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script src="https://unpkg.com/react@15/dist/react.min.js"></script>
    <script src="https://unpkg.com/react-dom@15/dist/react-dom.min.js"></script>

    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.5/marked.min.js"></script>


    <!-- Opal and Hyperloop -->
    <script src="https://rawgit.com/ruby-hyperloop/hyperloop-js/master/opal-compiler.min.js"></script>
    <script src="https://rawgit.com/ruby-hyperloop/hyperloop-js/master/hyperloop.min.js"></script>

    <!-- If you want local copies... -->
    <!-- <script src="../../../javascripts/opal-compiler.js"></script> -->
    <!-- <script src="../../../javascripts/hyperloop.js"></script> -->

    <script src="https://npmcdn.com/tether@1.2.4/dist/js/tether.min.js"></script>

    <script src="../../../javascripts/bootstrap.min.js"></script>
    <script src="../../../javascripts/codemirror.js"></script>
    <script src="../../../javascripts/ruby.js"></script>
    <script src="../../../javascripts/matchbrackets.js"></script>
    <script src="../../../javascripts/react_player.js"></script>
    <script src="../../../javascripts/highlight.pack.js"></script>


    <!-- Components are compiled by Hyperloop Express -->
    <script type="text/ruby">

class CodeMirror < Hyperloop::Component
  param :code, type: String
  param :heading, default: "Code"
  param :rows, type: Integer, default: 0
  param :top_level_component, type: String

  before_mount do
    r=rand(2**256).to_s(36)[0..7]
    @div_code = "code_#{r}"
    @div_result = "result_#{r}"
  end

  after_mount do
  # puts params.code
    @editor = `CodeMirror(document.getElementById(#{@div_code}), {
      value: #{params.code.to_s},
      mode: 'text/x-ruby',
      matchBrackets: true,
      lineNumbers: false,
      indentUnit: 2,
      theme: 'github'
    });`

    `#{@editor}.on('change', #{lambda {on_change} })`
    `#{@editor}.setSize(null, #{@editor}.defaultTextHeight()*#{params.rows})` unless params.rows == 0
    execute_code
  end

  render(DIV) do
    div.card {
      div.card_header { params.heading }
      div(id: @div_code)
      div.card_header do
        img(src: '../../../images/hyperloop-logo-small-white.png' , width:'25')
        span { ' ' }
        'Live editor results'
      end
      div.card_block(id: @div_result)
    }
  end

  def on_change
    execute_code
  end

  def execute_code
    begin
      code = `#{@editor}.getValue()`
      # puts code
      code += "\nElement['##{@div_result}'].render(#{params.top_level_component})"
      compiled_code = Opal::Compiler.new(code).compile

      `ReactDOM.unmountComponentAtNode(document.getElementById(#{@div_result}));`

      # Dispatchers and Receivers example works but Steps example breaks
      # Hyperloop::Context.reset!
      # `eval(#{compiled_code})`
      # Hyperloop::Application::Boot.run()

      # Steps example works but Dispatchers and Receivers example breaks
      `eval(#{compiled_code})`
      Hyperloop::Context.reset!
      Hyperloop::Application::Boot.run()

      component = Module.const_get params.top_level_component
      # we need to see if the component is valid - try checking if it can render static markup
      # the following line generates: `undefined method to_n for SimpleComponent`
      # if React.render_to_static_markup( component ).empty?
      #   invalid_component_message
      # end
    rescue Exception => e
      @time_out = after(0.1) do
        unable_to_compile_message e.message
      end
    end
  end

  def invalid_component_message
    message = div.text_danger do
      h3.text_danger {"Oops, invalid Component..."}
      p { "Your Component has been rejected by React. A valid Component must have a render macro and return just one HTML element." }
    end
    Element["##{@div_result}"].render{ message }
  end

  def unable_to_compile_message reason
    message = div.text_danger do
      h3.text_danger {"Can't compile..."}
      p { reason }
    end
    Element["##{@div_result}"].render{ message }
  end

end

</script>

    <script type="text/ruby">

Document.ready? do
   Element.find('div.codemirror-live-edit').each do |mount_point|
     heading = mount_point.attr('data-heading')
     rows = mount_point.attr('data-rows')
     top_level_component = mount_point.attr('data-top-level-component')
     code = Element[mount_point].find('pre').text.strip
     params = {code: code, top_level_component: top_level_component}
     params = params.merge({heading: heading}) if heading
     params = params.merge({rows: rows.to_i}) if rows
     codemirror_component = Object.const_get('CodeMirror')
     React.render(React.create_element(codemirror_component, params ), mount_point)
   end
end

</script>

    
    <script type="text/ruby">

class ToggleCodemirror < Hyperloop::Component
  param :code, type: String
  param :heading, default: "Code"
  param :rows, type: Integer, default: 0
  param :top_level_component, type: String
  param :show_code

  before_mount do
    r=rand(2**256).to_s(36)[0..7]
    @div_code = "code_#{r}"
    @div_result = "result_#{r}"
  end

  after_mount do
  # puts params.code
    @editor = `CodeMirror(document.getElementById(#{@div_code}), {
      value: #{params.code.to_s},
      mode: 'text/x-ruby',
      matchBrackets: true,
      lineNumbers: false,
      indentUnit: 2,
      readOnly: true,
      theme: 'github'
    });`

    `#{@editor}.setSize(null, #{@editor}.defaultTextHeight()*#{params.rows})` unless params.rows == 0

    Element['.codediv'].hide('')
    mutate.show_code false
    
  end

  render(DIV) do
    div.card {
      div.card_header do
        div(class: 'row') do
          div(class: 'col-md-6') do
            img(src: '../../../images/hyperloop-logo-small-white.png' , width:'25') 
            span { ' ' }
            span { params.heading }
          end
          div(class: 'col-md-6 align-right') do

            toggle_link
          end
        end
      end

      div(id: @div_code, class: 'codediv') 
    }
  end

  def toggle_link
    
      BUTTON(class: 'btn btn-info btn-sm') do
        state.show_code ? "Click to hide code" : "Click to show code"
      end.on(:click) do |ev|
        mutate.show_code !state.show_code 
        state.show_code ? Element["##{@div_code}"].show('') : Element["##{@div_code}"].hide('')
      end
    
  end

 
end

</script>

    <script type="text/ruby">

Document.ready? do
    Element.find('div.togglecode').each do |mount_point|
        heading = mount_point.attr('data-heading')
        rows = mount_point.attr('data-rows')
        top_level_component = mount_point.attr('data-top-level-component')
        code = Element[mount_point].find('pre').text.strip
        params = {code: code, top_level_component: top_level_component}
        params = params.merge({heading: heading}) if heading
        params = params.merge({rows: rows.to_i}) if rows
        codemirror_component = Object.const_get('ToggleCodemirror')
        React.render(React.create_element(codemirror_component, params ), mount_point)
    end
end

</script>

    <link href="../../../stylesheets/bootstrap.min.css" rel="stylesheet" />
    <link href="../../../stylesheets/typography.css" rel="stylesheet" />
    <link href="../../../stylesheets/override.css" rel="stylesheet" />
    <link href="../../../stylesheets/divtable.css" rel="stylesheet" />
    <!-- <link href="../../../stylesheets/code.css" rel="stylesheet" /> -->
    <link href="../../../stylesheets/github.css" rel="stylesheet" />
    <link href="../../../stylesheets/highlighting.css" rel="stylesheet" />
    <link href="../../../stylesheets/codemirror.css" rel="stylesheet" />
    <link href="../../../stylesheets/monokai-sublime.css" rel="stylesheet" />

    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />

    <!-- Favicons -->

    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="../../../images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="../../../images/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/images/manifest.json">
    <link rel="mask-icon" href="../../../images/safari-pinned-tab.svg" color="#e81176">
    <meta name="theme-color" content="#ffffff">

  </head>

  <body>
    <div class="navbarbackgroundcolor">
      <div class="container">
        <nav class="navbar navbar-ligh">
  <button class="navbar-toggler hidden-sm-up" type="button" data-toggle="collapse" data-target="#exCollapsingNavbar2" aria-controls="exCollapsingNavbar2" aria-expanded="false" aria-label="Toggle navigation">
    &#9776;
  </button>
  <div class="collapse navbar-toggleable-xs" id="exCollapsingNavbar2">
    <ul class="nav navbar-nav">
      <li class="nav-item">
        <a href="/" class="nav-link"><span class='navfirstletter'>H</span>yperloop</a>
      </li>
      <li class="nav-item">
        <a href="/start/components" class="nav-link active"><span class='navfirstletter'>S</span>tart</a>
      </li>
      <li class="nav-item">
        <a href="/installation" class="nav-link"><span class='navfirstletter'>I</span>nstallation</a>
      </li>
      <li class="nav-item">
        <a href="/tutorials" class="nav-link"><span class='navfirstletter'>T</span>utorials</a>
      </li>
      <li class="nav-item">
        <a href="/gems" class="nav-link"><span class='navfirstletter'>G</span>ems</a>
      </li>
      <li class="nav-item">
        <a href="https://github.com/ruby-hyperloop" class="nav-link"><span class='navfirstletter'>G</span>ithub</a>
      </li>
      <li class="nav-item">
        <a href="/tools" class="nav-link"><span class='navfirstletter'>T</span>ools</a>
      </li>
      <li class="nav-item">
        <a href="/docs/architecture" class="nav-link"><span class='navfirstletter'>D</span>ocs</a>
      </li>
      <li class="nav-item">
        <a href="/help" class="nav-link"><span class='navfirstletter'>H</span>elp</a>
      </li>
      <li class="nav-item">
        <a href="/blog" class="nav-link"><span class='navfirstletter'>B</span>log</a>
      </li>
      <!-- <li class="nav-item">
        <input type="text" name="search" />
      </li> -->
    </ul>
  </div>
</nav>

      </div>
    </div>



    

    <div class="jumbotron page-header">
      <div class="container">

        <div class="row hidden-sm-down">
          <div class="col-md-2">
            <div class="hyperlooplogo">
            </div>
          </div>
          <div class="col-md-8">

            <h1 class="display-4 project-name">Hyperloop</h1>

            <h4 class="display-7 project-tagline">
              
              The Complete Isomorphic Ruby Framework
            </h4>
          </div>
          
        </div>

        <div class="row hidden-md-up">
          <div class="col-md-3">
            <div class="hyperlooplogo">
            </div>
          </div>
          <div class="col-md-9">
            <h1 class="h1 project-name center-text">Hyperloop</h1>
            </br>
            <h2 class="h5 project-tagline center-text">
              The Complete Isomorphic Ruby Framework
            </h2>
          </div>
          
        </div>


      </div>
    </div>

    <div class="page-header-underline">
      <div class="container">

      </div>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-md-3 sidenavcol">
          
      <ul class="nav">
        <li class="nav-item"><a href="/docs/architecture">Hyperloop Architecture</a></li>
      </ul>

  <br>

    <ul class="navtoc">
<li class="navtoc-item">
<a href="#hyperloop-components">Hyperloop Components</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#components-dsl-overview">Components DSL Overview</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#hyperloop-component">Hyperloop::Component</a>
</li>
<li class="navtoc-item">
<a href="#macros-class-methods">Macros (Class Methods)</a>
</li>
<li class="navtoc-item">
<a href="#data-accessor-methods">Data Accessor Methods</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#params">Params</a>
</li>
<li class="navtoc-item">
<a href="#state">State</a>
</li>
<li class="navtoc-item">
<a href="#mutate">Mutate</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#tag-and-component-rendering">Tag and Component Rendering</a>
</li>
<li class="navtoc-item">
<a href="#using-strings">Using Strings</a>
</li>
<li class="navtoc-item">
<a href="#event-handlers">Event Handlers</a>
</li>
<li class="navtoc-item">
<a href="#miscellaneous-methods">Miscellaneous Methods</a>
</li>
<li class="navtoc-item">
<a href="#ruby-and-hyperloop">Ruby and Hyperloop</a>
</li>
<li class="navtoc-item">
<a href="#dsl-gotchas">DSL Gotchas</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#html-entities">HTML Entities</a>
</li>
<li class="navtoc-item">
<a href="#custom-html-attributes">Custom HTML Attributes</a>
</li>
<li class="navtoc-item">
<a href="#invoking-application-components">Invoking Application Components</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#components-and-state">Components and State</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#using-state">Using State</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#a-simple-example">A Simple Example</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#components-are-just-state-machines">Components are Just State Machines</a>
</li>
<li class="navtoc-item">
<a href="#how-state-works">How State Works</a>
</li>
<li class="navtoc-item">
<a href="#what-components-should-have-state">What Components Should Have State?</a>
</li>
<li class="navtoc-item">
<a href="#what-should-go-in-state">What <em>Should</em> Go in State?</a>
</li>
<li class="navtoc-item">
<a href="#what-shouldn-t-go-in-state">What <em>Shouldn't</em> Go in State?</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#multiple-components">Multiple Components</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#motivation-separation-of-concerns">Motivation: Separation of Concerns</a>
</li>
<li class="navtoc-item">
<a href="#composition-example">Composition Example</a>
</li>
<li class="navtoc-item">
<a href="#ownership">Ownership</a>
</li>
<li class="navtoc-item">
<a href="#children">Children</a>
</li>
<li class="navtoc-item">
<a href="#child-reconciliation">Child Reconciliation</a>
</li>
<li class="navtoc-item">
<a href="#stateful-children">Stateful Children</a>
</li>
<li class="navtoc-item">
<a href="#dynamic-children">Dynamic Children</a>
</li>
<li class="navtoc-item">
<a href="#data-flow">Data Flow</a>
</li>
<li class="navtoc-item">
<a href="#stores">Stores</a>
</li>
<li class="navtoc-item">
<a href="#reusable-components">Reusable Components</a>
</li>
<li class="navtoc-item">
<a href="#param-validation">Param Validation</a>
</li>
<li class="navtoc-item">
<a href="#default-param-values">Default Param Values</a>
</li>
<li class="navtoc-item">
<a href="#params-of-type-proc">Params of type Proc</a>
</li>
<li class="navtoc-item">
<a href="#other-params">Other Params</a>
</li>
<li class="navtoc-item">
<a href="#mixins-and-inheritance">Mixins and Inheritance</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#lifecycle-callbacks">Lifecycle Callbacks</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#the-param-macro">The param macro</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#accessing-param-values">Accessing param values</a>
</li>
<li class="navtoc-item">
<a href="#params-of-type-proc">Params of type Proc</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#the-state-instance-method">The state instance method</a>
</li>
<li class="navtoc-item">
<a href="#the-force_update-method">The force_update! method</a>
</li>
<li class="navtoc-item">
<a href="#the-dom_node-method">The dom_node method</a>
</li>
<li class="navtoc-item">
<a href="#the-children-method">The children method</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#lifecycle-methods">Lifecycle Methods</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#rendering">Rendering</a>
</li>
<li class="navtoc-item">
<a href="#before-mounting-first-render">Before Mounting (first render)</a>
</li>
<li class="navtoc-item">
<a href="#after-mounting-first-render">After Mounting (first render)</a>
</li>
<li class="navtoc-item">
<a href="#before-receiving-new-params">Before Receiving New Params</a>
</li>
<li class="navtoc-item">
<a href="#controlling-updates">Controlling Updates</a>
</li>
<li class="navtoc-item">
<a href="#before-updating-re-rendering">Before Updating (re-rendering)</a>
</li>
<li class="navtoc-item">
<a href="#after-updating-re-rendering">After Updating (re-rendering)</a>
</li>
<li class="navtoc-item">
<a href="#unmounting">Unmounting</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#event-handlers">Event Handlers</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#event-handling-and-synthetic-events">Event Handling and Synthetic Events</a>
</li>
<li class="navtoc-item">
<a href="#under-the-hood-event-delegation">Under the Hood: Event Delegation</a>
</li>
<li class="navtoc-item">
<a href="#react-event">React::Event</a>
</li>
<li class="navtoc-item">
<a href="#event-pooling">Event pooling</a>
</li>
<li class="navtoc-item">
<a href="#supported-events">Supported Events</a>
</li>
<li class="navtoc-item">
<a href="#clipboard-events">Clipboard Events</a>
</li>
<li class="navtoc-item">
<a href="#composition-events-not-tested">Composition Events (not tested)</a>
</li>
<li class="navtoc-item">
<a href="#keyboard-events">Keyboard Events</a>
</li>
<li class="navtoc-item">
<a href="#focus-events">Focus Events</a>
</li>
<li class="navtoc-item">
<a href="#form-events">Form Events</a>
</li>
<li class="navtoc-item">
<a href="#mouse-events">Mouse Events</a>
</li>
<li class="navtoc-item">
<a href="#drag-and-drop-example">Drag and Drop example</a>
</li>
<li class="navtoc-item">
<a href="#selection-events">Selection events</a>
</li>
<li class="navtoc-item">
<a href="#touch-events">Touch events</a>
</li>
<li class="navtoc-item">
<a href="#ui-events">UI Events</a>
</li>
<li class="navtoc-item">
<a href="#wheel-events">Wheel Events</a>
</li>
<li class="navtoc-item">
<a href="#media-events">Media Events</a>
</li>
<li class="navtoc-item">
<a href="#image-events">Image Events</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#elements-and-rendering">Elements and Rendering</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#react-create_element">React.create_element</a>
</li>
<li class="navtoc-item">
<a href="#react-is_valid_element">React.is_valid_element?</a>
</li>
<li class="navtoc-item">
<a href="#react-render">React.render</a>
</li>
<li class="navtoc-item">
<a href="#react-unmount_component_at_node">React.unmount_component_at_node</a>
</li>
<li class="navtoc-item">
<a href="#react-render_to_string">React.render_to_string</a>
</li>
<li class="navtoc-item">
<a href="#react-render_to_static_markup">React.render_to_static_markup</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#using-javascript-components">Using Javascript Components</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#importing-components">Importing Components</a>
</li>
<li class="navtoc-item">
<a href="#importing-libraries">Importing Libraries</a>
</li>
<li class="navtoc-item">
<a href="#auto-import">Auto Import</a>
</li>
<li class="navtoc-item">
<a href="#including-react-source">Including React Source</a>
</li>
<li class="navtoc-item">
<a href="#using-webpack">Using Webpack</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#server-side-rendering-or-prerendering">Server-side rendering (or Prerendering)</a>
</li>
<li class="navtoc-item">
<a href="#further-reading">Further Reading</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#other-hyperloop-tutorials-and-examples">Other Hyperloop tutorials and examples</a>
</li>
<li class="navtoc-item">
<a href="#react-under-the-covers">React under the covers</a>
</li>
<li class="navtoc-item">
<a href="#opal-under-the-covers">Opal under the covers</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


  <br>

    <ul class="nav">
      <li class="nav-item"><a href="/docs/stores/docs">Hyperloop Stores</a></li>
    </ul>


  <br>

    <ul class="nav">
      <li class="nav-item"><a href="/docs/router/docs">Hyperloop Router</a></li>
    </ul>

  <br>

    <ul class="nav">
      <li class="nav-item"><a href="/docs/models/docs">Hyperloop Models</a></li>
    </ul>

  <br>

   <ul class="nav">
      <li class="nav-item"><a href="/docs/operations/docs">Hyperloop Operations</a></li>
  </ul>

  <br>


    <ul class="nav">
      <li class="nav-item"><strong><a href="/docs/policies/docs">Hyperloop Policies</a></strong></li>
    </ul>



          <br>
        </div>
        <div class="col-md-9 main-content">
          <h1 id="hyperloop-components">Hyperloop Components</h1>

<h2 id="components-dsl-overview">Components DSL Overview</h2>

<p>Hyperloop <strong>Components</strong> are implemented in the hyper-component and hyper-react Gems.</p>

<p>Hyperloop Component DSL (Domain Specific Language) is a set of class and instance methods that are used to describe your React components.</p>

<p>The DSL has the following major areas:  </p>

<ul>
<li>The <code>Hyperloop::Component</code> class and the equivalent <code>Hyperloop::Component::Mixin</code> mixin</li>
<li>Class methods or <em>macros</em> that describe component class level behaviors</li>
<li>The four data accessors methods: <code>params</code>, <code>state</code>, <code>mutate</code>, and <code>children</code></li>
<li>The tag and component rendering methods</li>
<li>Event handlers</li>
<li>Miscellaneous methods</li>
</ul>

<h3 id="hyperloop-component">Hyperloop::Component</h3>

<p>Hyperloop Components classes either include <code>Hyperloop::Component::Mixin</code> or are subclasses of <code>Hyperloop::Component</code>.  </p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Component</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
<span class="k">end</span>

<span class="c1"># if subclassing is inappropriate, you can mixin instead</span>
<span class="k">class</span> <span class="nc">AnotherComponent</span>
  <span class="kp">include</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span><span class="o">::</span><span class="no">Mixin</span>
<span class="k">end</span>
</code></pre>
<p>At a minimum every component class must define a <code>render</code> macro which returns <strong>one single</strong> child element. That child may in turn have an arbitrarily deep structure.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Component</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">render</span> <span class="k">do</span>
    <span class="no">DIV</span> <span class="p">{</span> <span class="p">}</span> <span class="c1"># render an empty div</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>You may also include the top level element to be rendered:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Component</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">render</span><span class="p">(</span><span class="no">DIV</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># everything will be rendered in a div</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>To render a component, you reference its class name in the DSL as a method call.  This creates a new instance, passes any parameters proceeds with the component lifecycle.  </p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">AnotherComponent</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">render</span> <span class="k">do</span>
    <span class="no">Component</span><span class="p">()</span> <span class="c1"># ruby syntax requires either () or {} following the class name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Note that you should never redefine the <code>new</code> or <code>initialize</code> methods, or call them directly.  The equivalent of <code>initialize</code> is the <code>before_mount</code> callback.  </p>

<h3 id="macros-class-methods">Macros (Class Methods)</h3>

<p>Macros specify class wide behaviors.  </p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">MyComponent</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">before_mount</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">after_mount</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">before_unmount</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">render</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<p>The <code>param</code> macro describes the parameters the component expects.</p>

<p>The <code>before_mount</code> macro defines code to be run (a callback) when a component instance is first initialized.</p>

<p>The <code>after_mount</code> macro likewise runs after the instance has completed initialization, and is visible in the DOM.</p>

<p>The <code>before_unmount</code> macro provides any cleanup actions before the instance is destroyed.</p>

<p>The <code>render</code> macro defines the render method.</p>

<p>The available macros are: <code>render, param, state, mutate, before_mount, after_mount, before_receive_props, before_update, after_update, before_unmount</code></p>

<h3 id="data-accessor-methods">Data Accessor Methods</h3>

<p>The four data accessor methods - <code>params, state, mutate, and children</code> are instance methods that give access to a component&#39;s React specific instance data.</p>

<h4 id="params">Params</h4>

<p>The <code>params</code> method gives <em>read-only</em> access to each of the scalar params passed to the Component.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">WelcomeUser</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="ss">param: </span><span class="nb">id</span>

  <span class="n">render</span><span class="p">(</span><span class="no">DIV</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="nf">id</span><span class="p">)</span> <span class="c1"># user is mutable</span>
    <span class="n">user</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="s2">"Unknown"</span> <span class="k">unless</span> <span class="n">user</span><span class="p">.</span><span class="nf">name</span>
    <span class="no">SayHello</span><span class="p">(</span><span class="ss">name: </span><span class="n">user</span><span class="p">.</span><span class="nf">name</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">SayHello</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span> <span class="c1"># params.name is immutable and will validate as a String</span>

  <span class="n">render</span> <span class="k">do</span>
    <span class="no">H1</span> <span class="p">{</span> <span class="s2">"Hello </span><span class="si">#{</span><span class="n">params</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span> <span class="c1"># notice how you access name through parans</span>
  <span class="k">end</span>
</code></pre>
<p>A core design concept taken from React is that data flows down to child Components via params and params (called props in React) are immutable.</p>

<p>In Hyperloop, there are two exceptions to this rule:</p>

<ul>
<li>An instance of a Store (passed as a param) is mutable and changes to the state of the Store will cause a re-render</li>
<li>An instance of a Model (which is a type of Store) will also case a re-render when changed</li>
</ul>

<p>In the example below, clicking on the button will cause the Component to re-render (even though <code>book</code> is a <code>param</code>) because <code>book</code> is a Model. If <code>book</code> were not a Model then the Component would not re-render.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Likes</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:book</span> <span class="c1"># book is an instance of the Book model</span>

  <span class="n">render</span><span class="p">(</span><span class="no">DIV</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">P</span> <span class="p">{</span> <span class="s2">"</span><span class="si">#{</span><span class="n">params</span><span class="p">.</span><span class="nf">book</span><span class="p">.</span><span class="nf">likes</span><span class="p">.</span><span class="nf">count</span><span class="si">}</span><span class="s2"> likes"</span> <span class="p">}</span>
    <span class="no">BUTTON</span> <span class="p">{</span> <span class="s2">"Like"</span> <span class="p">}.</span><span class="nf">on</span><span class="p">(</span><span class="ss">:click</span><span class="p">)</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">book</span><span class="p">.</span><span class="nf">likes</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<blockquote>
<p>Note: Non-scalar params (objects) which are mutable through their methods are not read only. Care should be taken here as changes made to these objects will <strong>not</strong> cause a re-render of the Component. Specifically, if you pass a non-scalar param into a Component, and modify the internal data of that param, Hyperloop will not be notified to re-render the Component (as it does not know about the internal structure of your object). To achieve a re-render in this circumstance you will need to ensure that the parts of your object which are mutable are declared as state in a higher-order parent Component so that data can flow down from the parent to the child as per the React pattern.</p>
</blockquote>

<h4 id="state">State</h4>

<p>In React (and Hyperloop) state is mutable. Changes to state variables cause Components to re-render and where state is passed into a child Component as a param, it will cause a re-rendering of that child Component. Change flows from a parent to a child - change does not flow upward and this is why params are not mutable.</p>

<p>State variables are (optionally) initialized and accessed through the <code>state</code> method.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Counter</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">state</span> <span class="ss">count: </span><span class="mi">0</span> <span class="c1"># optional initialization</span>

  <span class="n">render</span><span class="p">(</span><span class="no">DIV</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">BUTTON</span> <span class="p">{</span> <span class="s2">"+"</span> <span class="p">}.</span><span class="nf">on</span><span class="p">(</span><span class="ss">:click</span><span class="p">)</span> <span class="p">{</span> <span class="n">mutate</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="nf">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
    <span class="no">P</span> <span class="p">{</span> <span class="n">state</span><span class="p">.</span><span class="nf">count</span><span class="p">.</span><span class="nf">to_s</span> <span class="p">}</span> <span class="c1"># note how we access the count variable</span>
  <span class="k">end</span>
<span class="k">end</span>  
</code></pre>
<p>See <a href="#using-state">Using State</a> for more information on State.</p>

<h4 id="mutate">Mutate</h4>

<p>The <code>mutate</code> method initializes (or updates) a reactive state variable. State variables are like <em>reactive</em> instance variables.  They can only be changed using the <code>mutate</code> method, and when they change they will cause a re-render.  </p>
<pre class="highlight ruby"><code><span class="n">before_mount</span> <span class="k">do</span>
  <span class="n">mutate</span><span class="p">.</span><span class="nf">game_over</span> <span class="kp">false</span>
<span class="k">end</span>
</code></pre>
<p>More on the details of these methods can be found in the <a href="#top-level-api">Component API</a> section.</p>

<h3 id="tag-and-component-rendering">Tag and Component Rendering</h3>
<pre class="highlight ruby"><code>  <span class="p">.</span><span class="nf">.</span><span class="o">.</span>
    <span class="no">DIV</span><span class="p">(</span><span class="ss">class: :time</span><span class="p">)</span> <span class="k">do</span>
      <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
    <span class="nf">end</span>
  <span class="p">.</span><span class="nf">.</span><span class="o">.</span>
</code></pre>
<blockquote>
<p><strong>Note on coding style:</strong> In the Hyperloop documentation and tutorials we use uppercase HTML elements like <code>DIV</code> and <code>BUTTON</code> as we believe this makes for greater readability in the code; specifically with code highlighting. If you do not like this you can use lowercase <code>div</code> and <code>button</code> instead.</p>
</blockquote>

<p>HTML such as <code>DIV, A, SELECT, OPTION</code> etc. each have a corresponding instance method that will render that tag.  For all the tags the
method call looks like this:</p>
<pre class="highlight ruby"><code><span class="n">tag_name</span><span class="p">(</span><span class="n">attribute1</span> <span class="o">=&gt;</span> <span class="n">value1</span><span class="p">,</span> <span class="n">attribute2</span> <span class="o">=&gt;</span> <span class="n">value2</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span> <span class="k">do</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span><span class="nf">nested</span> <span class="n">tags</span><span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<p>Each key-value pair in the parameter block is passed down as an attribute to the tag as you would expect, with the exception of the <code>style</code> attribute, which takes a hash that is translated to the corresponding style string.</p>

<p>The same rules apply for application defined components, except that the class constant is used to reference the component.</p>
<pre class="highlight ruby"><code><span class="no">Clock</span><span class="p">(</span><span class="ss">mode: </span><span class="mi">12</span><span class="p">)</span>
</code></pre>
<h3 id="using-strings">Using Strings</h3>

<p>Strings are treated specially as follows:  </p>

<p>If a render method or a nested tag block returns a string, the string is automatically wrapped in a <code>&lt;span&gt;</code> tag.</p>

<p>The code <code>SPAN { &quot;hello&quot; }</code> can be shortened to <code>&quot;hello&quot;.SPAN</code>, likewise for <code>BR, PARA, TD, TH</code> tags.</p>

<p><code>&quot;some string&quot;.BR</code> generates <code>&lt;span&gt;some string&lt;span&gt;&lt;br/&gt;</code></p>
<pre class="highlight ruby"><code><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">strftime</span><span class="p">(</span><span class="no">FORMATS</span><span class="p">[</span><span class="n">state</span><span class="p">.</span><span class="nf">mode</span><span class="p">])</span><span class="o">.</span><span class="no">SPAN</span>  <span class="c1"># generates &lt;span&gt;...current time formatted...&lt;/span&gt;</span>
<span class="p">.</span><span class="nf">.</span><span class="o">.</span>
  <span class="no">OPTION</span><span class="p">(</span><span class="ss">value: </span><span class="mi">12</span><span class="p">)</span> <span class="p">{</span> <span class="s2">"12 Hour Clock"</span> <span class="p">}</span>      <span class="c1"># generates &lt;option value=12&gt;&lt;span&gt;12 Hour Clock&lt;/span&gt;&lt;/option&gt;</span>
</code></pre>
<h3 id="event-handlers">Event Handlers</h3>

<p>Event Handlers are attached to tags and components using the <code>on</code> method.</p>
<pre class="highlight ruby"><code><span class="no">SELECT</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span> <span class="nf">do</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="ss">:change</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
  <span class="n">mutate</span><span class="p">.</span><span class="nf">mode</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="nf">target</span><span class="p">.</span><span class="nf">value</span><span class="p">.</span><span class="nf">to_i</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<p>The <code>on</code> method takes the event name symbol (note that <code>onClick</code> becomes <code>:click</code>) and the block is passed the React.js event object.</p>

<p>Event handlers can be chained like so</p>
<pre class="highlight ruby"><code><span class="no">INPUT</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span> <span class="nf">do</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">end</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="ss">:key_up</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">end</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="ss">:change</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<h3 id="miscellaneous-methods">Miscellaneous Methods</h3>

<p><code>force_update!</code> is a component instance method that causes the component to re-rerender. This method is seldom (if ever) needed.</p>

<p><code>as_node</code> can be attached to a component or tag, and removes the element from the rendering buffer and returns it.   This is useful when you need store an element in some data structure, or passing to a native JS component.  When passing an element to another Hyperloop Component <code>.as_node</code> will be automatically applied so you normally don&#39;t need it.  </p>

<p><code>render</code> can be applied to the objects returned by <code>as_node</code> and <code>children</code> to actually render the node.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Test</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:node</span>

  <span class="n">render</span> <span class="k">do</span>
    <span class="no">DIV</span> <span class="k">do</span>
      <span class="n">children</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span>
        <span class="n">params</span><span class="p">.</span><span class="nf">node</span><span class="p">.</span><span class="nf">render</span>
        <span class="n">child</span><span class="p">.</span><span class="nf">render</span>
      <span class="k">end</span>
      <span class="n">params</span><span class="p">.</span><span class="nf">node</span><span class="p">.</span><span class="nf">render</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<h3 id="ruby-and-hyperloop">Ruby and Hyperloop</h3>

<p>A key design goal of the DSL is to make it work seamlessly with the rest of Ruby.  Notice in the above example, the use of constant declaration (<code>FORMATS</code>), regular instance variables (<code>@timer</code>), and other non-react methods like <code>every</code> (an Opal Browser method).  </p>

<p>Component classes can be organized like any other class into a logical module hierarchy or even subclassed.</p>

<p>Likewise the render method can invoke other methods to compute values or even internally build tags.</p>

<h3 id="dsl-gotchas">DSL Gotchas</h3>

<p>There are few gotchas with the DSL you should be aware of:</p>

<p>React has implemented a browser-independent events and DOM system for performance and cross-browser compatibility reasons. We took the opportunity to clean up a few rough edges in browser DOM implementations.</p>

<ul>
<li>All DOM properties and attributes (including event handlers) should be snake_cased to be consistent with standard Ruby style. We intentionally break with the spec here since the spec is inconsistent. <strong>However</strong>, <code>data-*</code> and <code>aria-*</code> attributes <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#data-*">conform to the specs</a> and should be lower-cased only.</li>
<li>The <code>style</code> attribute accepts a Hash with camelCased properties rather than a CSS string. This  is more efficient, and prevents XSS security holes.</li>
<li>All event objects conform to the W3C spec, and all events (including submit) bubble correctly per the W3C spec. See <a href="#event-handling-and-synthetic-events">Event System</a> for more details.</li>
<li>The <code>onChange</code> event (<code>on(:change)</code>) behaves as you would expect it to: whenever a form field is changed this event is fired rather than inconsistently on blur. We intentionally break from existing browser behavior because <code>onChange</code> is a misnomer for its behavior and React relies on this event to react to user input in real time.</li>
<li>Form input attributes such as <code>value</code> and <code>checked</code>, as well as <code>textarea</code>.</li>
</ul>

<h4 id="html-entities">HTML Entities</h4>

<p>If you want to display an HTML entity within dynamic content, you will run into double escaping issues as React.js escapes all the strings you are displaying in order to prevent a wide range of XSS attacks by default.</p>
<pre class="highlight ruby"><code><span class="no">DIV</span> <span class="p">{</span><span class="s1">'First &amp;middot; Second'</span> <span class="p">}</span>
  <span class="c1"># Bad: It displays "First &amp;middot; Second"</span>
</code></pre>
<p>To workaround this you have to insert raw HTML.</p>
<pre class="highlight ruby"><code><span class="no">DIV</span><span class="p">(</span><span class="ss">dangerously_set_inner_HTML: </span><span class="p">{</span> <span class="ss">__html: </span><span class="s2">"First &amp;middot; Second"</span><span class="p">})</span>
</code></pre>
<h4 id="custom-html-attributes">Custom HTML Attributes</h4>

<p>If you pass properties to native HTML elements that do not exist in the HTML specification, React will not render them. If you want to use a custom attribute, you should prefix it with <code>data-</code>.</p>
<pre class="highlight ruby"><code><span class="no">DIV</span><span class="p">(</span><span class="s2">"data-custom-attribute"</span> <span class="o">=&gt;</span> <span class="s2">"foo"</span><span class="p">)</span>
</code></pre>
<p><a href="http://www.w3.org/WAI/intro/aria">Web Accessibility</a> attributes starting with <code>aria-</code> will be rendered properly.</p>
<pre class="highlight ruby"><code><span class="no">DIV</span><span class="p">(</span><span class="s2">"aria-hidden"</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
</code></pre>
<h4 id="invoking-application-components">Invoking Application Components</h4>

<p>When invoking a custom component you must have a (possibly empty) parameter list or (possibly empty) block.  This is not necessary
with standard html tags.</p>
<pre class="highlight ruby"><code><span class="no">MyCustomComponent</span><span class="p">()</span>  <span class="c1"># okay</span>
<span class="no">MyCustomComponent</span> <span class="p">{}</span> <span class="c1"># okay</span>
<span class="no">MyCustomComponent</span>    <span class="c1"># breaks</span>
<span class="n">br</span>                   <span class="c1"># okay</span>
</code></pre>
<h2 id="components-and-state">Components and State</h2>

<h3 id="using-state">Using State</h3>

<h4 id="a-simple-example">A Simple Example</h4>

<div class="codemirror-live-edit"
  data-heading="A simple Component rendering state"
  data-rows=12
  data-top-level-component="LikeButton">
<pre>
class LikeButton < Hyperloop::Component

  render(DIV) do
    P do
      "You #{state.liked ? 'like' : 'haven\'t liked'} this. Click to toggle."
    end.on(:click) do
      mutate.liked !state.liked
    end
  end
end
</pre></div>

<h3 id="components-are-just-state-machines">Components are Just State Machines</h3>

<p>React thinks of UIs as simple state machines. By thinking of a UI as being in various states and rendering those states, it&#39;s easy to keep your UI consistent.</p>

<p>In React, you simply update a component&#39;s state, and then the new UI will be rendered on this new state. React takes care of updating the DOM for you in the most efficient way.</p>

<h3 id="how-state-works">How State Works</h3>

<p>To change a state variable you use <code>mutate.state_variable</code> and pass the new value.  For example <code>mutate.liked(!state.like)</code> <em>gets</em> the current value of like, toggles it, and then <em>updates</em> it.  This in turn causes the component to be rerendered. For more details on how this works, and the full syntax of the update method see <a href="#top-level-api">the component API reference</a></p>

<h3 id="what-components-should-have-state">What Components Should Have State?</h3>

<p>Most of your components should simply take some params and render based on their value. However, sometimes you need to respond to user input, a server request or the passage of time. For this you use state.</p>

<p><strong>Try to keep as many of your components as possible stateless.</strong> By doing this you&#39;ll isolate the state to its most logical place and minimize redundancy, making it easier to reason about your application.</p>

<p>A common pattern is to create several stateless components that just render data, and have a stateful component above them in the hierarchy that passes its state to its children via <code>params</code>. The stateful component encapsulates all of the interaction logic, while the stateless components take care of rendering data in a declarative way.</p>

<h3 id="what-should-go-in-state">What <em>Should</em> Go in State?</h3>

<p><strong>State should contain data that a component&#39;s event handlers, timers, or http requests may change and trigger a UI update.</strong></p>

<p>When building a stateful component, think about the minimal possible representation of its state, and only store those properties in <code>state</code>.  Add to your class methods to compute higher level values from your state variables.  Avoid adding redundant or computed values as state variables as
these values must then be kept in sync whenever state changes.</p>

<h3 id="what-shouldnt-go-in-state">What <em>Shouldn&#39;t</em> Go in State?</h3>

<p><code>state</code> should only contain the minimal amount of data needed to represent your UI&#39;s state. As such, it should not contain:</p>

<ul>
<li><strong>Computed data:</strong> Don&#39;t worry about precomputing values based on state — it&#39;s easier to ensure that your UI is consistent if you do all computation during rendering.  For example, if you have an array of list items in state and you want to render the count as a string, simply render <code>&quot;#{state.list_items.length} list items&#39;</code> in your <code>render</code> method rather than storing the count as another state.</li>
<li><strong>Data that does not effect rendering:</strong> For example handles on timers, that need to be cleaned up when a component unmounts should go
in plain old instance variables.</li>
</ul>

<h2 id="multiple-components">Multiple Components</h2>

<p>So far, we&#39;ve looked at how to write a single component to display data and handle user input. Next let&#39;s examine one of React&#39;s finest features: composability.</p>

<h3 id="motivation-separation-of-concerns">Motivation: Separation of Concerns</h3>

<p>By building modular components that reuse other components with well-defined interfaces, you get much of the same benefits that you get by using functions or classes. Specifically you can <em>separate the different concerns</em> of your app however you please simply by building new components. By building a custom component library for your application, you are expressing your UI in a way that best fits your domain.</p>

<h3 id="composition-example">Composition Example</h3>

<p>Let&#39;s create a simple Avatar component which shows a profile picture and username using the Facebook Graph API.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Avatar</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:user_name</span>
  <span class="n">render</span><span class="p">(</span><span class="no">DIV</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">ProfilePic</span>  <span class="ss">user_name: </span><span class="n">params</span><span class="p">.</span><span class="nf">user_name</span>
    <span class="no">ProfileLink</span> <span class="ss">user_name: </span><span class="n">params</span><span class="p">.</span><span class="nf">user_name</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">ProfilePic</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:user_name</span>
  <span class="n">render</span> <span class="k">do</span>
    <span class="no">IMG</span> <span class="ss">src: </span><span class="s2">"https://graph.facebook.com/</span><span class="si">#{</span><span class="n">params</span><span class="p">.</span><span class="nf">user_name</span><span class="si">}</span><span class="s2">/picture"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">ProfileLink</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:user_name</span>
  <span class="n">render</span> <span class="k">do</span>
    <span class="no">A</span> <span class="ss">href: </span><span class="s2">"https://www.facebook.com/</span><span class="si">#{</span><span class="n">params</span><span class="p">.</span><span class="nf">user_name</span><span class="si">}</span><span class="s2">"</span> <span class="k">do</span>
      <span class="n">params</span><span class="p">.</span><span class="nf">user_name</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<h3 id="ownership">Ownership</h3>

<p>In the above example, instances of <code>Avatar</code> <em>own</em> instances of <code>ProfilePic</code> and <code>ProfileLink</code>. In React, <strong>an owner is the component that sets the <code>params</code> of other components</strong>. More formally, if a component <code>X</code> is created in component <code>Y</code>&#39;s <code>render</code> method, it is said that <code>X</code> is <em>owned by</em> <code>Y</code>. As discussed earlier, a component cannot mutate its <code>params</code> — they are always consistent with what its owner sets them to. This fundamental invariant leads to UIs that are guaranteed to be consistent.</p>

<p>It&#39;s important to draw a distinction between the owner-ownee relationship and the parent-child relationship. The owner-ownee relationship is specific to React, while the parent-child relationship is simply the one you know and love from the DOM. In the example above, <code>Avatar</code> owns the <code>div</code>, <code>ProfilePic</code> and <code>ProfileLink</code> instances, and <code>div</code> is the <strong>parent</strong> (but not owner) of the <code>ProfilePic</code> and <code>ProfileLink</code> instances.</p>

<h3 id="children">Children</h3>

<p>When you create a React component instance, you can include additional React components or JavaScript expressions between the opening and closing tags like this:</p>
<pre class="highlight ruby"><code><span class="no">Parent</span> <span class="p">{</span> <span class="no">Child</span><span class="p">()</span> <span class="p">}</span>
</code></pre>
<p><code>Parent</code> can iterate over its children by accessing its <code>children</code> method.</p>

<h3 id="child-reconciliation">Child Reconciliation</h3>

<p><strong>Reconciliation is the process by which React updates the DOM with each new render pass.</strong> In general, children are reconciled according to the order in which they are rendered. For example, suppose we have the following render method displaying a list of items.  On each pass
the items will be completely rerendered:</p>
<pre class="highlight ruby"><code><span class="n">render</span> <span class="k">do</span>
  <span class="n">params</span><span class="p">.</span><span class="nf">items</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>
    <span class="n">para</span> <span class="k">do</span>
      <span class="n">item</span><span class="p">[</span><span class="ss">:text</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>What if the first time items was <code>[{text: &quot;foo&quot;}, {text: &quot;bar&quot;}]</code>, and the second time items was <code>[{text: &quot;bar&quot;}]</code>?
Intuitively, the paragraph <code>&lt;p&gt;foo&lt;/p&gt;</code> was removed. Instead, React will reconcile the DOM by changing the text content of the first child and destroying the last child. React reconciles according to the <em>order</em> of the children.</p>

<h3 id="stateful-children">Stateful Children</h3>

<p>For most components, this is not a big deal. However, for stateful components that maintain data in <code>state</code> across render passes, this can be very problematic.</p>

<p>In most cases, this can be sidestepped by hiding elements based on some property change:</p>
<pre class="highlight ruby"><code><span class="n">render</span> <span class="k">do</span>
  <span class="n">state</span><span class="p">.</span><span class="nf">items</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>
    <span class="no">PARA</span><span class="p">(</span><span class="ss">style: </span><span class="p">{</span><span class="ss">display: </span><span class="n">item</span><span class="p">[</span><span class="ss">:some_property</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"some state"</span> <span class="p">?</span> <span class="p">:</span><span class="n">block</span> <span class="p">:</span> <span class="ss">:none</span><span class="p">})</span> <span class="k">do</span>
      <span class="n">item</span><span class="p">[</span><span class="ss">:text</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<h3 id="dynamic-children">Dynamic Children</h3>

<p>The situation gets more complicated when the children are shuffled around (as in search results) or if new components are added onto the front of the list (as in streams). In these cases where the identity and state of each child must be maintained across render passes, you can uniquely identify each child by assigning it a <code>key</code>:</p>
<pre class="highlight ruby"><code>  <span class="n">param</span> <span class="ss">:results</span><span class="p">,</span> <span class="ss">type: </span><span class="p">[</span><span class="no">Hash</span><span class="p">]</span> <span class="c1"># each result is a hash of the form {id: ..., text: ....}</span>
  <span class="n">render</span> <span class="k">do</span>
    <span class="no">OL</span> <span class="k">do</span>
      <span class="n">params</span><span class="p">.</span><span class="nf">results</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="o">|</span>
        <span class="no">LI</span><span class="p">(</span><span class="ss">key: </span><span class="n">result</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span> <span class="p">{</span> <span class="n">result</span><span class="p">[</span><span class="ss">:text</span><span class="p">]</span> <span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre>
<p>When React reconciles the keyed children, it will ensure that any child with <code>key</code> will be reordered (instead of clobbered) or destroyed (instead of reused).</p>

<p>The <code>key</code> should <em>always</em> be supplied directly to the components in the array, not to the container HTML child of each component in the array:</p>
<pre class="highlight ruby"><code><span class="c1"># WRONG!</span>
<span class="k">class</span> <span class="nc">ListItemWrapper</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:data</span>
  <span class="n">render</span> <span class="k">do</span>
    <span class="no">LI</span><span class="p">(</span><span class="ss">key: </span><span class="n">params</span><span class="p">.</span><span class="nf">data</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">data</span><span class="p">[</span><span class="ss">:text</span><span class="p">]</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>    
<span class="k">class</span> <span class="nc">MyComponent</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:results</span>
  <span class="n">render</span> <span class="k">do</span>
    <span class="no">UL</span> <span class="k">do</span>
      <span class="n">params</span><span class="p">.</span><span class="nf">result</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="o">|</span>
        <span class="no">ListItemWrapper</span> <span class="ss">data: </span><span class="n">result</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre><pre class="highlight ruby"><code><span class="c1"># CORRECT</span>
<span class="k">class</span> <span class="nc">ListItemWrapper</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:data</span>
  <span class="n">render</span> <span class="k">do</span>
    <span class="no">LI</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">data</span><span class="p">[</span><span class="ss">:text</span><span class="p">]</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">class</span> <span class="nc">MyComponent</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:results</span>
  <span class="n">render</span> <span class="k">do</span>
    <span class="no">UL</span> <span class="k">do</span>
      <span class="n">params</span><span class="p">.</span><span class="nf">result</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="o">|</span>
        <span class="no">ListItemWrapper</span> <span class="ss">key: </span><span class="n">result</span><span class="p">[</span><span class="ss">:id</span><span class="p">],</span> <span class="ss">data: </span><span class="n">result</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<h3 id="data-flow">Data Flow</h3>

<p>In React, data flows from owner to owned component through the params as discussed above. This is effectively one-way data binding: owners bind their owned component&#39;s param to some value the owner has computed based on its <code>params</code> or <code>state</code>. Since this process happens recursively, data changes are automatically reflected everywhere they are used.</p>

<h3 id="stores">Stores</h3>

<p>Managing state between components is best done using Stores as many Components can access one store. This saves passing data btween Components. Please see the <a href="/docs/stores/docs">Store documentation</a> for details.</p>

<h3 id="reusable-components">Reusable Components</h3>

<p>When designing interfaces, break down the common design elements (buttons, form fields, layout components, etc.) into reusable components with well-defined interfaces. That way, the next time you need to build some UI, you can write much less code. This means faster development time, fewer bugs, and fewer bytes down the wire.</p>

<h3 id="param-validation">Param Validation</h3>

<p>As your app grows it&#39;s helpful to ensure that your components are used correctly. We do this by allowing you to specify the expected ruby class of your parameters. When an invalid value is provided for a param, a warning will be shown in the JavaScript console. Note that for performance reasons type checking is only done in development mode. Here is an example showing typical type specifications:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">ManyParams</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:an_array</span><span class="p">,</span>         <span class="ss">type: </span><span class="p">[]</span> <span class="c1"># or type: Array</span>
  <span class="n">param</span> <span class="ss">:a_string</span><span class="p">,</span>         <span class="ss">type: </span><span class="no">String</span>
  <span class="n">param</span> <span class="ss">:array_of_strings</span><span class="p">,</span> <span class="ss">type: </span><span class="p">[</span><span class="no">String</span><span class="p">]</span>
  <span class="n">param</span> <span class="ss">:a_hash</span><span class="p">,</span>           <span class="ss">type: </span><span class="no">Hash</span>
  <span class="n">param</span> <span class="ss">:some_class</span><span class="p">,</span>       <span class="ss">type: </span><span class="no">SomeClass</span> <span class="c1"># works with any class</span>
  <span class="n">param</span> <span class="ss">:a_string_or_nil</span><span class="p">,</span>  <span class="ss">type: </span><span class="no">String</span><span class="p">,</span> <span class="ss">allow_nil: </span><span class="kp">true</span>
<span class="k">end</span>
</code></pre>
<p>Note that if the param can be nil, add <code>allow_nil: true</code> to the specification.</p>

<h3 id="default-param-values">Default Param Values</h3>

<p>React lets you define default values for your <code>params</code>:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">ManyParams</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:an_optional_param</span><span class="p">,</span> <span class="ss">default: </span><span class="s2">"hello"</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span><span class="p">,</span> <span class="ss">allow_nil: </span><span class="kp">true</span>
</code></pre>
<p>If no value is provided for <code>:an_optional_param</code> it will be given the value <code>&quot;hello&quot;</code></p>

<h3 id="params-of-type-proc">Params of type Proc</h3>

<p>A Ruby <code>Proc</code> can be passed to a component like any other object.  The <code>param</code> macro treats params declared as type <code>Proc</code> specially, and will automatically call the proc when the param name is used on the params method.</p>
<pre class="highlight ruby"><code><span class="n">param</span> <span class="ss">:all_done</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Proc</span>
<span class="p">.</span><span class="nf">.</span><span class="o">.</span>
  <span class="c1"># typically in an event handler</span>
<span class="n">params</span><span class="p">.</span><span class="nf">all_done</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># instead of params.all_done.call(data)</span>
</code></pre>
<p>Proc params can be optional, using the <code>default: nil</code> and <code>allow_nil: true</code> options.  Invoking a nil proc param will do nothing.  This is handy for allowing optional callbacks.</p>

<h3 id="other-params">Other Params</h3>

<p>A common type of React component is one that extends a basic HTML element in a simple way. Often you&#39;ll want to copy any HTML attributes passed to your component to the underlying HTML element.</p>

<p>To do this use the <code>collect_other_params_as</code> macro which will gather all the params you did not declare into a hash. Then you can pass this hash on to the child component</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">CheckLink</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">collect_other_params_as</span> <span class="ss">:attributes</span>
  <span class="n">render</span> <span class="k">do</span>
    <span class="c1"># we just pass along any incoming attributes</span>
    <span class="n">a</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="p">{</span> <span class="s1">'√ '</span><span class="p">.</span><span class="nf">span</span><span class="p">;</span> <span class="n">children</span><span class="p">.</span><span class="nf">each</span> <span class="o">&amp;</span><span class="ss">:render</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="c1"># CheckLink(href: "/checked.html")</span>
</code></pre>
<p>Note: <code>collect_other_params_as</code> builds a hash, so you can merge other data in or even delete elements out as needed.</p>

<h3 id="mixins-and-inheritance">Mixins and Inheritance</h3>

<p>Ruby has a rich set of mechanisms enabling code reuse, and Hyperloop is intended to be a team player in your Ruby application.  Components can be subclassed, and they can include (or mixin) other modules.  You can also create a component by including <code>Hyperloop::Component::Mixin</code> which allows a class to inherit from some other non-react class, and then mixin the React DSL.</p>
<pre class="highlight ruby"><code>  <span class="c1"># make a SuperFoo react component class</span>
  <span class="k">class</span> <span class="nc">Foo</span> <span class="o">&lt;</span> <span class="no">SuperFoo</span>
    <span class="kp">include</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span><span class="o">::</span><span class="no">Mixin</span>
  <span class="k">end</span>
</code></pre>
<p>One common use case is a component wanting to update itself on a time interval. It&#39;s easy to use the kernel method <code>every</code>, but it&#39;s important to cancel your interval when you don&#39;t need it anymore to save memory. React provides <a href="/docs/working-with-the-browser.html#component-lifecycle">lifecycle methods</a> that let you know when a component is about to be created or destroyed. Let&#39;s create a simple mixin that uses these methods to provide a React friendly <code>every</code> function that will automatically get cleaned up when your component is destroyed.</p>

<div class="codemirror-live-edit"
  data-heading="Using state"
  data-rows=33
  data-top-level-component="TickTock">
<pre>
module ReactInterval

  def self.included(base)
    base.before_mount do
      @intervals = []
    end

    base.before_unmount do
      @intervals.each(&:stop)
    end
  end

  def every(seconds, &block)
    Kernel.every(seconds, &block).tap { |i| @intervals << i }
  end
end

class TickTock < Hyperloop::Component
  include ReactInterval

  before_mount do
    state.seconds! 0
  end

  after_mount do
    every(1) { mutate.seconds state.seconds+1}
  end

  render(DIV) do
    "Hyperloop has been running for #{state.seconds} seconds".para
  end
end
</pre></div>

<p>Notice that TickTock effectively has two before_mount callbacks, one that is called to initialize the <code>@intervals</code> array and another to initialize <code>state.seconds</code></p>

<h2 id="lifecycle-callbacks">Lifecycle Callbacks</h2>

<p>A component may define callbacks for each phase of the components lifecycle:</p>

<ul>
<li><code>before_mount</code></li>
<li><code>render</code></li>
<li><code>after_mount</code></li>
<li><code>before_receive_props</code></li>
<li><code>before_update</code></li>
<li><code>after_update</code></li>
<li><code>before_unmount</code></li>
</ul>

<p>All the callback macros may take a block or the name of an instance method to be called.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">AComponent</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">before_mount</span> <span class="k">do</span>
    <span class="c1"># initialize stuff here</span>
  <span class="k">end</span>
  <span class="n">before_unmount</span> <span class="ss">:cleanup</span>  <span class="c1"># call the cleanup method before unmounting</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<p>Except for the render callback, multiple callbacks may be defined for each lifecycle phase, and will be executed in the order defined, and from most deeply nested subclass outwards.</p>

<p>Details on the component lifecycle is described <a href="docs/component-specs.html">here</a></p>

<h3 id="the-param-macro">The param macro</h3>

<p>Within a React Component the <code>param</code> macro is used to define the parameter signature of the component.  You can think of params as
the values that would normally be sent to the instance&#39;s <code>initialize</code> method, but with the difference that a React Component gets new parameters when it is rerendered.  </p>

<p>The param macro has the following syntax:</p>
<pre class="highlight ruby"><code><span class="n">param</span> <span class="n">symbol</span><span class="p">,</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span><span class="nf">options</span><span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="c1"># or</span>
<span class="n">param</span> <span class="n">symbol</span> <span class="o">=&gt;</span> <span class="n">default_value</span><span class="p">,</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span><span class="nf">options</span><span class="p">.</span><span class="nf">.</span><span class="o">.</span>
</code></pre>
<p>Available options are <code>:default_value =&gt; ...any value...</code> and <code>:type =&gt; ...class_spec...</code>
where class_spec is either a class name, or <code>[]</code> (shorthand for Array), or <code>[ClassName]</code> (meaning array of <code>ClassName</code>.)</p>

<p>Note that the default value can be specied either as the hash value of the symbol, or explicitly using the <code>:default_value</code> key.</p>

<p>Examples:</p>
<pre class="highlight ruby"><code><span class="n">param</span> <span class="ss">:foo</span> <span class="c1"># declares that we must be provided with a parameter foo when the component is instantiated or re-rerendered.</span>
<span class="n">param</span> <span class="ss">:foo</span> <span class="o">=&gt;</span> <span class="s2">"some default"</span>        <span class="c1"># declares that foo is optional, and if not present the value "some default" will be used.</span>
<span class="n">param</span> <span class="ss">foo: </span><span class="s2">"some default"</span>           <span class="c1"># same as above using ruby 1.9 JSON style syntax</span>
<span class="n">param</span> <span class="ss">:foo</span><span class="p">,</span> <span class="ss">default: </span><span class="s2">"some default"</span> <span class="c1"># same as above but uses explicit default key</span>
<span class="n">param</span> <span class="ss">:foo</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span>            <span class="c1"># foo is required and must be of type String</span>
<span class="n">param</span> <span class="ss">:foo</span><span class="p">,</span> <span class="ss">type: </span><span class="p">[</span><span class="no">String</span><span class="p">]</span>          <span class="c1"># foo is required and must be an array of Strings</span>
<span class="n">param</span> <span class="ss">foo: </span><span class="p">[],</span> <span class="ss">type: </span><span class="p">[</span><span class="no">String</span><span class="p">]</span>       <span class="c1"># foo must be an array of strings, and has a default value of the empty array.</span>
</code></pre>
<h4 id="accessing-param-values">Accessing param values</h4>

<p>The component instance method <code>params</code> gives access to all declared params.  So for example</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Hello</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">visitor: </span><span class="s2">"World"</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span>

  <span class="n">render</span> <span class="k">do</span>
    <span class="s2">"Hello </span><span class="si">#{</span><span class="n">params</span><span class="p">.</span><span class="nf">visitor</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<h4 id="params-of-type-proc">Params of type Proc</h4>

<p>A param of type proc (i.e. <code>param :update, type: Proc</code>) gets special treatment that will directly
call the proc when the param is accessed.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Alarm</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">param</span> <span class="ss">:at</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Time</span>
  <span class="n">param</span> <span class="ss">:notify</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Proc</span>

  <span class="n">after_mount</span> <span class="k">do</span>
    <span class="vi">@clock</span> <span class="o">=</span> <span class="n">every</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">do</span>
      <span class="k">if</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">&gt;</span> <span class="n">params</span><span class="p">.</span><span class="nf">at</span>
        <span class="n">params</span><span class="p">.</span><span class="nf">notify</span>
        <span class="vi">@clock</span><span class="p">.</span><span class="nf">stop</span>
      <span class="k">end</span>
      <span class="n">force_update!</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">render</span> <span class="k">do</span>
    <span class="s2">"</span><span class="si">#{</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>If for whatever reason you need to get the actual proc instead of calling it use <code>params.method(*symbol name of method*)</code></p>

<h3 id="the-state-instance-method">The state instance method</h3>

<p>React state variables are <em>reactive</em> component instance variables that cause rerendering when they change.</p>

<p>State variables are accessed via the <code>state</code> instance method which works like the <code>params</code> method. Like normal instance variables, state variables are created when they are first accessed, so there is no explicit declaration.  </p>

<p>To access the value of a state variable <code>foo</code> you would say <code>state.foo</code>.  </p>

<p>To initialize or update a state variable you use <code>mutate.</code> followed by its name.  For example <code>mutate.foo []</code> would initialize <code>foo</code> to an empty array.  Unlike the assignment operator, the mutate method returns the current value (before it is changed.)</p>

<p>Often state variables have complex values with their own internal state, an array for example.  The problem is as you push new values onto the array you are not changing the object pointed to by the state variable, but its internal state.</p>

<p>To handle this use the same <code>mutate</code> prefix with <strong>no</strong> parameter, and then apply any update methods to the resulting value.  The underlying value will be updated, <strong>and</strong> the underlying system will be notified that a state change has occurred.</p>

<p>For example:</p>
<pre class="highlight ruby"><code>  <span class="n">mutate</span><span class="p">.</span><span class="nf">foo</span> <span class="p">[]</span>    <span class="c1"># initialize foo (returns nil)</span>
    <span class="c1">#...later...</span>
  <span class="n">mutate</span><span class="p">.</span><span class="nf">foo</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span>  <span class="c1"># push 12 onto foo's array</span>
    <span class="c1">#...or...</span>
  <span class="n">mutate</span><span class="p">.</span><span class="nf">foo</span> <span class="p">{}</span>
  <span class="n">mutate</span><span class="p">.</span><span class="nf">foo</span><span class="p">[</span><span class="ss">:house</span> <span class="o">=&gt;</span> <span class="ss">:boat</span><span class="p">]</span>
</code></pre>
<p>The rule is simple:  anytime you are updating a state variable use <code>mutate</code>.
<br><br></p>

<blockquote>
<h4 id="tell-me-how-that-works">Tell Me How That Works???</h4>

<p>A state variables mutate method can optionally accept one parameter.  If a parameter is passed, then the method will 1) save the current value, 2) update the value to the passed parameter, 3) update the underlying react.js state object, 4) return the saved value.</p>
</blockquote>

<h4 id="the-force_update-method">The force_update! method</h4>

<p>The <code>force_update!</code> instance method causes the component to re-render.  Usually this is not necessary as rendering will occur when state variables change, or new params are passed.  For a good example of using <code>force_update!</code> see the <code>Alarm</code> component above.  In this case there is no reason to have a state track of the time separately, so we just call <code>force_update!</code> every second.</p>

<h4 id="the-dom_node-method">The dom_node method</h4>

<p>Returns the dom<em>node that this component instance is mounted to.  Typically used in the `after</em>mount` callback to setup linkages to external libraries.</p>

<h4 id="the-children-method">The children method</h4>

<p>Along with params components may be passed a block which is used to build the components children.</p>

<p>The instance method <code>children</code> returns an enumerable that is used to access the unrendered children of a component.</p>

<div class="codemirror-live-edit"
  data-heading="The children method"
  data-rows=20
  data-top-level-component="Indenter">
<pre>
class IndentEachLine < Hyperloop::Component
  param by: 20, type: Integer

  render(DIV) do
    children.each_with_index do |child, i|
      child.render(style: {"margin-left" => params.by*i})
    end
  end
end

class Indenter < Hyperloop::Component
  render(DIV) do
    IndentEachLine(by: 100) do
      DIV {"Line 1"}
      DIV {"Line 2"}
      DIV {"Line 3"}
    end
  end
end
</pre></div>

<h3 id="lifecycle-methods">Lifecycle Methods</h3>

<p>A component class may define callbacks for  specific points in a component&#39;s lifecycle.</p>

<h4 id="rendering">Rendering</h4>

<p>The lifecycle revolves around rendering the component.  As the state or parameters of a component changes, its render method will be called to generate the new HTML.  The rest of the callbacks hook into the lifecycle before or after rendering.</p>

<p>For reasons described below Hyperloop provides a render callback to simplify defining the render method:</p>
<pre class="highlight ruby"><code><span class="n">render</span> <span class="k">do</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span><span class="nf">.</span>
<span class="k">end</span>
</code></pre>
<p>The render callback will generate the components render method.  It may optionally take the container component and params:</p>
<pre class="highlight ruby"><code><span class="n">render</span><span class="p">(</span><span class="ss">:DIV</span><span class="p">,</span> <span class="ss">class: </span><span class="s1">'my-class'</span><span class="p">)</span> <span class="k">do</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<p>which would be equivilent to:</p>
<pre class="highlight ruby"><code><span class="n">render</span> <span class="k">do</span>
  <span class="no">DIV</span><span class="p">(</span><span class="ss">class: </span><span class="s1">'my-class'</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">end</span>
<span class="k">end</span>
</code></pre>
<p>The purpose of the render callback is syntactic.  Many components consist of a static outer container with possibly some parameters, and most component&#39;s render method by necessity will be longer than the normal <em>10 line</em> ruby style guideline.  The render call back solves both these problems by allowing the outer container to be specified as part of the callback parameter (which reads very nicely) and because the render code is now specified as a block you avoid the 10 line limitation, while encouraging the rest of your methods to adhere to normal ruby style guides</p>

<h4 id="before-mounting-first-render">Before Mounting (first render)</h4>
<pre class="highlight ruby"><code><span class="n">before_mount</span> <span class="k">do</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<p>Invoked once when the component is first instantiated, immediately before the initial rendering occurs. This is where state variables should
be initialized.</p>

<p>This is the only life cycle method that is called during <code>render_to_string</code> used in server side pre-rendering.</p>

<h4 id="after-mounting-first-render">After Mounting (first render)</h4>
<pre class="highlight ruby"><code><span class="n">after_mount</span> <span class="k">do</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<p>Invoked once, only on the client (not on the server), immediately after the initial rendering occurs. At this point in the lifecycle, you can access any refs to your children (e.g., to access the underlying DOM representation). The <code>after_mount</code> callbacks of children components are invoked before that of parent components.</p>

<p>If you want to integrate with other JavaScript frameworks, set timers using the <code>after</code> or <code>every</code> methods, or send AJAX requests, perform those operations in this method.  Attempting to perform such operations in before_mount will cause errors during prerendering because none of these operations are available in the server environment.</p>

<h4 id="before-receiving-new-params">Before Receiving New Params</h4>
<pre class="highlight ruby"><code><span class="n">before_receive_props</span> <span class="k">do</span> <span class="o">|</span><span class="n">new_params_hash</span><span class="o">|</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<p>Invoked when a component is receiving <em>new</em> params (React.js props). This method is not called for the initial render.</p>

<p>Use this as an opportunity to react to a prop transition before <code>render</code> is called by updating any instance or state variables. The
new_props block parameter contains a hash of the new values.</p>
<pre class="highlight ruby"><code><span class="n">before_receive_props</span> <span class="k">do</span> <span class="o">|</span><span class="n">next_props</span><span class="o">|</span>
  <span class="n">state</span><span class="p">.</span><span class="nf">likes_increasing!</span> <span class="p">(</span><span class="n">next_props</span><span class="p">[</span><span class="ss">:like_count</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">params</span><span class="p">.</span><span class="nf">like_count</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<blockquote>
<p>Note:</p>

<p>There is no analogous method <code>before_receive_state</code>. An incoming param may cause a state change, but the opposite is not true. If you need to perform operations in response to a state change, use <code>before_update</code>.</p>
</blockquote>

<h4 id="controlling-updates">Controlling Updates</h4>

<p>Normally Hyperloop will only update a component if some state variable or param has changed.  To override this behavior you can redefine the <code>should_component_update?</code> instance method.  For example, assume that we have a state called <code>funky</code> that for whatever reason, we
cannot update using the normal <code>state.funky!</code> update method.  So what we can do is override <code>should_component_update?</code> call <code>super</code>, and then double check if the <code>funky</code> has changed by doing an explicit comparison.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">RerenderMore</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="k">def</span> <span class="nf">should_component_update?</span><span class="p">(</span><span class="n">new_params_hash</span><span class="p">,</span> <span class="n">new_state_hash</span><span class="p">)</span>
    <span class="k">super</span> <span class="o">||</span> <span class="n">new_state_hash</span><span class="p">[</span><span class="ss">:funky</span><span class="p">]</span> <span class="o">!=</span> <span class="n">state</span><span class="p">.</span><span class="nf">funky</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Why would this happen?  Most likely there is integration between new Hyperloop Components and other data structures being maintained outside of Hyperloop, and so we have to do some explicit comparisons to detect the state change.</p>

<p>Note that <code>should_component_update?</code> is not called for the initial render or when <code>force_update!</code> is used.</p>

<blockquote>
<p>Note to react.js readers.  Essentially Hyperloop assumes components are &quot;well behaved&quot; in the sense that all state changes
will be explicitly declared using the state update (&quot;!&quot;) method when changing state.  This gives similar behavior to a
&quot;pure&quot; component without the possible performance penalties.
To achieve the standard react.js behavior add this line to your class <code>def should_component_update?; true; end</code></p>
</blockquote>

<h4 id="before-updating-re-rendering">Before Updating (re-rendering)</h4>
<pre class="highlight ruby"><code><span class="n">before_update</span> <span class="k">do</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<p>Invoked immediately before rendering when new params or state are bein#g received.  </p>

<h4 id="after-updating-re-rendering">After Updating (re-rendering)</h4>
<pre class="highlight ruby"><code><span class="n">after_update</span> <span class="k">do</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<p>Invoked immediately after the component&#39;s updates are flushed to the DOM. This method is not called for the initial render.</p>

<p>Use this as an opportunity to operate on the DOM when the component has been updated.</p>

<h4 id="unmounting">Unmounting</h4>
<pre class="highlight ruby"><code><span class="n">before_unmount</span> <span class="k">do</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<p>Invoked immediately before a component is unmounted from the DOM.</p>

<p>Perform any necessary cleanup in this method, such as invalidating timers or cleaning up any DOM elements that were created in the <code>after_mount</code> callback.</p>

<h3 id="event-handlers">Event Handlers</h3>

<h4 id="event-handling-and-synthetic-events">Event Handling and Synthetic Events</h4>

<p>With React you attach event handlers to elements using the <code>on</code> method. React ensures that all events behave identically in IE8 and above by implementing a synthetic event system. That is, React knows how to bubble and capture events according to the spec, and the events passed to your event handler are guaranteed to be consistent with <a href="http://www.w3.org/TR/DOM-Level-3-Events/">the W3C spec</a>, regardless of which browser you&#39;re using.</p>

<h4 id="under-the-hood-event-delegation">Under the Hood: Event Delegation</h4>

<p>React doesn&#39;t actually attach event handlers to the nodes themselves. When React starts up, it starts listening for all events at the top level using a single event listener. When a component is mounted or unmounted, the event handlers are simply added or removed from an internal mapping. When an event occurs, React knows how to dispatch it using this mapping. When there are no event handlers left in the mapping, React&#39;s event handlers are simple no-ops. To learn more about why this is fast, see <a href="http://davidwalsh.name/event-delegate">David Walsh&#39;s excellent blog post</a>.</p>

<h4 id="react-event">React::Event</h4>

<p>Your event handlers will be passed instances of <code>React::Event</code>, a wrapper around react.js&#39;s <code>SyntheticEvent</code> which in turn is a cross browser wrapper around the browser&#39;s native event. It has the same interface as the browser&#39;s native event, including <code>stopPropagation()</code> and <code>preventDefault()</code>, except the events work identically across all browsers.</p>

<p>For example:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">YouSaid</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>

  <span class="n">render</span><span class="p">(</span><span class="no">DIV</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">INPUT</span><span class="p">(</span><span class="ss">value: </span><span class="n">state</span><span class="p">.</span><span class="nf">value</span><span class="p">).</span>
    <span class="nf">on</span><span class="p">(</span><span class="ss">:key_down</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
      <span class="n">alert</span> <span class="s2">"You said: </span><span class="si">#{</span><span class="n">state</span><span class="p">.</span><span class="nf">value</span><span class="si">}</span><span class="s2">"</span> <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="nf">key_code</span> <span class="o">==</span> <span class="mi">13</span>
    <span class="k">end</span><span class="p">.</span>
    <span class="nf">on</span><span class="p">(</span><span class="ss">:change</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
      <span class="n">mutate</span><span class="p">.</span><span class="nf">value</span> <span class="n">e</span><span class="p">.</span><span class="nf">target</span><span class="p">.</span><span class="nf">value</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>If you find that you need the underlying browser event for some reason use the <code>native_event</code>.  </p>

<p>In the following responses shown as (native ...) indicate the value returned is a native object with an Opal wrapper.  In some cases there will be opal methods available (i.e. for native DOMNode values) and in other cases you will have to convert to the native value
with <code>.to_n</code> and then use javascript directly.</p>

<p>Every <code>React::Event</code> has the following methods:</p>
<pre class="highlight ruby"><code><span class="n">bubbles</span>                <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">cancelable</span>             <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">current_target</span>         <span class="o">-&gt;</span> <span class="p">(</span><span class="n">native</span> <span class="no">DOM</span> <span class="n">node</span><span class="p">)</span>
<span class="n">default_prevented</span>      <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">event_phase</span>            <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">is_trusted</span>             <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">native_event</span>           <span class="o">-&gt;</span> <span class="p">(</span><span class="n">native</span> <span class="no">Event</span><span class="p">)</span>
<span class="n">prevent_default</span>        <span class="o">-&gt;</span> <span class="no">Proc</span>
<span class="n">is_default_prevented</span>   <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">stop_propagation</span>       <span class="o">-&gt;</span> <span class="no">Proc</span>
<span class="n">is_propagation_stopped</span> <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">target</span>                 <span class="o">-&gt;</span> <span class="p">(</span><span class="n">native</span> <span class="no">DOMEventTarget</span><span class="p">)</span>
<span class="n">timestamp</span>              <span class="o">-&gt;</span> <span class="no">Integer</span> <span class="p">(</span><span class="n">use</span> <span class="no">Time</span><span class="p">.</span><span class="nf">at</span> <span class="n">to</span> <span class="n">convert</span> <span class="n">to</span> <span class="no">Time</span><span class="p">)</span>
<span class="n">type</span>                   <span class="o">-&gt;</span> <span class="no">String</span>
</code></pre>
<h4 id="event-pooling">Event pooling</h4>

<p>The underlying React <code>SyntheticEvent</code> is pooled. This means that the <code>SyntheticEvent</code> object will be reused and all properties will be nullified after the event callback has been invoked. This is for performance reasons. As such, you cannot access the event in an asynchronous way.</p>

<h4 id="supported-events">Supported Events</h4>

<p>React normalizes events so that they have consistent properties across
different browsers.</p>

<h4 id="clipboard-events">Clipboard Events</h4>

<p>Event names:</p>
<pre class="highlight ruby"><code><span class="ss">:copy</span><span class="p">,</span> <span class="ss">:cut</span><span class="p">,</span> <span class="ss">:paste</span>
</code></pre>
<p>Available Methods:</p>
<pre class="highlight ruby"><code><span class="n">clipboard_data</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">native</span> <span class="no">DOMDataTransfer</span><span class="p">)</span>
</code></pre>
<h4 id="composition-events-not-tested">Composition Events (not tested)</h4>

<p>Event names:</p>
<pre class="highlight ruby"><code><span class="ss">:composition_end</span><span class="p">,</span> <span class="ss">:composition_start</span><span class="p">,</span> <span class="ss">:composition_update</span>
</code></pre>
<p>Available Methods:</p>
<pre class="highlight ruby"><code><span class="n">data</span> <span class="o">-&gt;</span> <span class="no">String</span>
</code></pre>
<h4 id="keyboard-events">Keyboard Events</h4>

<p>Event names:</p>
<pre class="highlight ruby"><code><span class="ss">:key_down</span><span class="p">,</span> <span class="ss">:key_press</span><span class="p">,</span> <span class="ss">:key_up</span>
</code></pre>
<p>Available Methods:</p>
<pre class="highlight ruby"><code><span class="n">alt_key</span>                 <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">char_code</span>               <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">ctrl_key</span>                <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">get_modifier_state</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="no">Boolean</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="nf">e</span><span class="p">.</span> <span class="nf">get_modifier_key</span><span class="p">(</span><span class="ss">:Shift</span><span class="p">)</span>
<span class="n">key</span>                     <span class="o">-&gt;</span> <span class="no">String</span>
<span class="n">key_code</span>                <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">locale</span>                  <span class="o">-&gt;</span> <span class="no">String</span>
<span class="n">location</span>                <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">meta_key</span>                <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">repeat</span>                  <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">shift_key</span>               <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">which</span>                   <span class="o">-&gt;</span> <span class="no">Integer</span>
</code></pre>
<h4 id="focus-events">Focus Events</h4>

<p>Event names:</p>
<pre class="highlight ruby"><code><span class="ss">:focus</span><span class="p">,</span> <span class="ss">:blur</span>
</code></pre>
<p>Available Methods:</p>
<pre class="highlight ruby"><code><span class="n">related_target</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="no">Native</span> <span class="no">DOMEventTarget</span><span class="p">)</span>
</code></pre>
<p>These focus events work on all elements in the React DOM, not just form elements.</p>

<h4 id="form-events">Form Events</h4>

<p>Event names:</p>
<pre class="highlight ruby"><code><span class="ss">:change</span><span class="p">,</span> <span class="ss">:input</span><span class="p">,</span> <span class="ss">:submit</span>
</code></pre>
<h4 id="mouse-events">Mouse Events</h4>

<p>Event names:</p>
<pre class="highlight ruby"><code><span class="ss">:click</span><span class="p">,</span> <span class="ss">:context_menu</span><span class="p">,</span> <span class="ss">:double_click</span><span class="p">,</span> <span class="ss">:drag</span><span class="p">,</span> <span class="ss">:drag_end</span><span class="p">,</span> <span class="ss">:drag_enter</span><span class="p">,</span> <span class="ss">:drag_exit</span>
<span class="ss">:drag_leave</span><span class="p">,</span> <span class="ss">:drag_over</span><span class="p">,</span> <span class="ss">:drag_start</span><span class="p">,</span> <span class="ss">:drop</span><span class="p">,</span> <span class="ss">:mouse_down</span><span class="p">,</span> <span class="ss">:mouse_enter</span><span class="p">,</span>
<span class="ss">:mouse_leave</span><span class="p">,</span> <span class="ss">:mouse_move</span><span class="p">,</span> <span class="ss">:mouse_out</span><span class="p">,</span> <span class="ss">:mouse_over</span><span class="p">,</span> <span class="ss">:mouse_up</span>
</code></pre>
<p>The <code>:mouse_enter</code> and <code>:mouse_leave</code> events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.</p>

<p>Available Methods:</p>
<pre class="highlight ruby"><code><span class="n">alt_key</span>                 <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">button</span>                  <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">buttons</span>                 <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">client_x</span>                <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">number</span> <span class="n">client_y</span>         <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">ctrl_key</span>                <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">get_modifier_state</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">meta_key</span>                <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">page_x</span>                  <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">page_y</span>                  <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">related_target</span>          <span class="o">-&gt;</span> <span class="p">(</span><span class="no">Native</span> <span class="no">DOMEventTarget</span><span class="p">)</span>
<span class="n">screen_x</span>                <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">screen_y</span>                <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">shift_key</span>               <span class="o">-&gt;</span> <span class="no">Boolean</span>
</code></pre>
<h4 id="drag-and-drop-example">Drag and Drop example</h4>

<p>Here is a Hyperloop version of this <a href="https://www.w3schools.com/html/html5_draganddrop.asp">w3schools.com</a> example:</p>
<pre class="highlight ruby"><code><span class="no">DIV</span><span class="p">(</span><span class="ss">id: </span><span class="s2">"div1"</span><span class="p">,</span> <span class="ss">style: </span><span class="p">{</span><span class="ss">width: </span><span class="mi">350</span><span class="p">,</span> <span class="ss">height: </span><span class="mi">70</span><span class="p">,</span> <span class="ss">padding: </span><span class="mi">10</span><span class="p">,</span> <span class="ss">border: </span><span class="s1">'1px solid #aaaaaa'</span><span class="p">})</span>
  <span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="ss">:drop</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">ev</span><span class="o">|</span>
    <span class="n">ev</span><span class="p">.</span><span class="nf">prevent_default</span>
    <span class="n">data</span> <span class="o">=</span> <span class="sb">`</span><span class="si">#{</span><span class="n">ev</span><span class="p">.</span><span class="nf">native_event</span><span class="si">}</span><span class="sb">.native.dataTransfer.getData("text")`</span>
    <span class="sb">`</span><span class="si">#{</span><span class="n">ev</span><span class="p">.</span><span class="nf">target</span><span class="si">}</span><span class="sb">.native.appendChild(document.getElementById(data))`</span>
  <span class="k">end</span>
  <span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="ss">:drag_over</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">ev</span><span class="o">|</span> <span class="n">ev</span><span class="p">.</span><span class="nf">prevent_default</span> <span class="p">}</span>

<span class="no">IMG</span><span class="p">(</span><span class="ss">id: </span><span class="s2">"drag1"</span><span class="p">,</span> <span class="ss">src: </span><span class="s2">"https://www.w3schools.com/html/img_logo.gif"</span><span class="p">,</span> <span class="ss">draggable: </span><span class="s2">"true"</span><span class="p">,</span> <span class="ss">width: </span><span class="mi">336</span><span class="p">,</span> <span class="ss">height: </span><span class="mi">69</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="ss">:drag_start</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">ev</span><span class="o">|</span>
    <span class="sb">`</span><span class="si">#{</span><span class="n">ev</span><span class="p">.</span><span class="nf">native_event</span><span class="si">}</span><span class="sb">.native.dataTransfer.setData("text", </span><span class="si">#{</span><span class="n">ev</span><span class="p">.</span><span class="nf">target</span><span class="si">}</span><span class="sb">.native.id)`</span>
  <span class="k">end</span>
</code></pre>
<h4 id="selection-events">Selection events</h4>

<p>Event names:</p>
<pre class="highlight ruby"><code><span class="n">onSelect</span>
</code></pre>
<h4 id="touch-events">Touch events</h4>

<p>Event names:</p>
<pre class="highlight ruby"><code><span class="ss">:touch_cancel</span><span class="p">,</span> <span class="ss">:touch_end</span><span class="p">,</span> <span class="ss">:touch_move</span><span class="p">,</span> <span class="ss">:touch_start</span>
</code></pre>
<p>Available Methods:</p>
<pre class="highlight ruby"><code><span class="n">alt_key</span>                 <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">changed_touches</span>         <span class="o">-&gt;</span> <span class="p">(</span><span class="no">Native</span> <span class="no">DOMTouchList</span><span class="p">)</span>
<span class="n">ctrl_key</span>                <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">get_modifier_state</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">meta_key</span>                <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">shift_key</span>               <span class="o">-&gt;</span> <span class="no">Boolean</span>
<span class="n">target_touches</span>          <span class="o">-&gt;</span> <span class="p">(</span><span class="no">Native</span> <span class="no">DOMTouchList</span><span class="p">)</span>
<span class="n">touches</span>                 <span class="o">-&gt;</span> <span class="p">(</span><span class="no">Native</span> <span class="no">DomTouchList</span><span class="p">)</span>
</code></pre>
<h4 id="ui-events">UI Events</h4>

<p>Event names:</p>
<pre class="highlight ruby"><code><span class="ss">:scroll</span>
</code></pre>
<p>Available Methods:</p>
<pre class="highlight ruby"><code><span class="n">detail</span> <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">view</span>   <span class="o">-&gt;</span> <span class="p">(</span><span class="no">Native</span> <span class="no">DOMAbstractView</span><span class="p">)</span>
</code></pre>
<h4 id="wheel-events">Wheel Events</h4>

<p>Event names:</p>
<pre class="highlight ruby"><code><span class="n">wheel</span>
</code></pre>
<p>Available Methods:</p>
<pre class="highlight ruby"><code><span class="n">delta_mode</span> <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">delta_x</span>    <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">delta_y</span>    <span class="o">-&gt;</span> <span class="no">Integer</span>
<span class="n">delta_z</span>    <span class="o">-&gt;</span> <span class="no">Integer</span>
</code></pre>
<h4 id="media-events">Media Events</h4>

<p>Event names:</p>
<pre class="highlight ruby"><code><span class="ss">:abort</span><span class="p">,</span> <span class="ss">:can_play</span><span class="p">,</span> <span class="ss">:can_play_through</span><span class="p">,</span> <span class="ss">:duration_change</span><span class="p">,</span><span class="ss">:emptied</span><span class="p">,</span> <span class="ss">:encrypted</span><span class="p">,</span> <span class="ss">:ended</span><span class="p">,</span> <span class="ss">:error</span><span class="p">,</span> <span class="ss">:loaded_data</span><span class="p">,</span>
<span class="ss">:loaded_metadata</span><span class="p">,</span> <span class="ss">:load_start</span><span class="p">,</span> <span class="ss">:pause</span><span class="p">,</span> <span class="ss">:play</span><span class="p">,</span> <span class="ss">:playing</span><span class="p">,</span> <span class="ss">:progress</span><span class="p">,</span> <span class="ss">:rate_change</span><span class="p">,</span> <span class="ss">:seeked</span><span class="p">,</span> <span class="ss">:seeking</span><span class="p">,</span> <span class="ss">:stalled</span><span class="p">,</span>
<span class="ss">:on_suspend</span><span class="p">,</span> <span class="ss">:time_update</span><span class="p">,</span> <span class="ss">:volume_change</span><span class="p">,</span> <span class="ss">:waiting</span>
</code></pre>
<h4 id="image-events">Image Events</h4>

<p>Event names:</p>
<pre class="highlight ruby"><code><span class="ss">:load</span><span class="p">,</span> <span class="ss">:error</span>
</code></pre>
<h3 id="elements-and-rendering">Elements and Rendering</h3>

<h4 id="react-create_element">React.create_element</h4>

<p>A React Element is a component class, a set of parameters, and a group of children.  When an element is rendered the parameters and used to initialize a new instance of the component.</p>

<p><code>React.create_element</code> creates a new element.  It takes either the component class, or a string (representing a built in tag such as div, or span), the parameters (properties) to be passed to the element, and optionally a block that will be evaluated to build the enclosed children elements</p>
<pre class="highlight ruby"><code><span class="no">React</span><span class="p">.</span><span class="nf">create_element</span><span class="p">(</span><span class="s2">"div"</span><span class="p">,</span> <span class="ss">prop1: </span><span class="s2">"foo"</span><span class="p">,</span> <span class="ss">prop2: </span><span class="mi">12</span><span class="p">)</span> <span class="p">{</span> <span class="n">para</span> <span class="p">{</span> <span class="s2">"hello"</span> <span class="p">};</span> <span class="n">para</span> <span class="p">{</span> <span class="s2">"goodby"</span> <span class="p">}</span> <span class="p">)</span>
  <span class="c1"># when rendered will generates &lt;div prop1="foo" prop2="12"&gt;&lt;p&gt;hello&lt;/p&gt;&lt;p&gt;goodby&lt;/p&gt;&lt;/div&gt;</span>
</code></pre>
<p><strong>You almost never need to directly call <code>create_element</code>, the DSL, Rails, and jQuery interfaces take care of this for you.</strong></p>
<pre class="highlight ruby"><code><span class="c1"># dsl - creates element and pushes it into the rendering buffer</span>
<span class="no">MyComponent</span><span class="p">(.</span><span class="nf">.</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span><span class="nf">optional</span> <span class="n">children</span><span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>

<span class="c1"># dsl - component will NOT be placed in the rendering buffer</span>
<span class="no">MyComponent</span><span class="p">(.</span><span class="nf">.</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}.</span><span class="nf">as_node</span>

<span class="c1"># in a rails controller - renders component as the view</span>
<span class="n">render_component</span><span class="p">(</span><span class="s2">"MyComponent"</span><span class="p">,</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>

<span class="c1"># in a rails view helper - renders component into the view (like a partial)</span>
<span class="n">react_component</span><span class="p">(</span><span class="s2">"MyComponent"</span><span class="p">,</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>

<span class="c1"># from jQuery (Note Element is the Opal jQuery wrapper, not be confused with React::Element)</span>
<span class="no">Element</span><span class="p">[</span><span class="s1">'#container'</span><span class="p">].</span><span class="nf">render</span> <span class="p">{</span> <span class="no">MyComponent</span><span class="p">(.</span><span class="nf">.</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span><span class="nf">optional</span> <span class="n">children</span><span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span> <span class="p">}</span>  
</code></pre>
<h4 id="react-is_valid_element">React.is_valid_element?</h4>
<pre class="highlight ruby"><code><span class="n">is_valid_element?</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
</code></pre>
<p>Verifies <code>object</code> is a valid react element.  Note that <code>React::Element</code> wraps the React.js native class,
<code>React.is_valid_element?</code> returns true for both classes unlike <code>object.is_a? React::Element</code></p>

<h4 id="react-render">React.render</h4>
<pre class="highlight ruby"><code><span class="no">React</span><span class="p">.</span><span class="nf">render</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"element rendered"</span> <span class="p">}</span>
</code></pre>
<p>Render an <code>element</code> into the DOM in the supplied <code>container</code> and return a <a href="/docs/more-about-refs.html">reference</a> to the component.</p>

<p>The container can either be a DOM node or a jQuery selector (i.e. Element[&#39;#container&#39;]) in which case the first element is the container.</p>

<p>If the element was previously rendered into <code>container</code>, this will perform an update on it and only mutate the DOM as necessary to reflect the latest React component.</p>

<p>If the optional block is provided, it will be executed after the component is rendered or updated.</p>

<blockquote>
<p>Note:</p>

<p><code>React.render()</code> controls the contents of the container node you pass in. Any existing DOM elements inside are replaced when first called. Later calls use React’s DOM diffing algorithm for efficient updates.</p>

<p><code>React.render()</code> does not modify the container node (only modifies the children of the container). In the future, it may be possible to insert a component to an existing DOM node without overwriting the existing children.</p>
</blockquote>

<h4 id="react-unmount_component_at_node">React.unmount_component_at_node</h4>
<pre class="highlight ruby"><code><span class="no">React</span><span class="p">.</span><span class="nf">unmount_component_at_node</span><span class="p">(</span><span class="n">container</span><span class="p">)</span>
</code></pre>
<p>Remove a mounted React component from the DOM and clean up its event handlers and state. If no component was mounted in the container, calling this function does nothing. Returns <code>true</code> if a component was unmounted and <code>false</code> if there was no component to unmount.</p>

<h4 id="react-render_to_string">React.render_to_string</h4>
<pre class="highlight ruby"><code><span class="no">React</span><span class="p">.</span><span class="nf">render_to_string</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
</code></pre>
<p>Render an element to its initial HTML. This is should only be used on the server for prerendering content. React will return a string containing the HTML. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.</p>

<p>If you call <code>React.render</code> on a node that already has this server-rendered markup, React will preserve it and only attach event handlers, allowing you to have a very performant first-load experience.</p>

<p>If you are using rails, then the prerendering functions are automatically performed.  Otherwise you can use <code>render_to_string</code> to build your own prerendering system.</p>

<h4 id="react-render_to_static_markup">React.render_to_static_markup</h4>
<pre class="highlight ruby"><code><span class="no">React</span><span class="p">.</span><span class="nf">render_to_static_markup</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
</code></pre>
<p>Similar to <code>render_to_string</code>, except this doesn&#39;t create extra DOM attributes such as <code>data-react-id</code>, that React uses internally. This is useful if you want to use React as a simple static page generator, as stripping away the extra attributes can save lots of bytes.</p>

<h3 id="using-javascript-components">Using Javascript Components</h3>

<p>While it is quite possible to develop large applications purely in Hyperloop Components with a ruby back end like rails, you may eventually find you want to use some pre-existing React Javascript library.   Or you may be working with an existing React-JS application, and want to just start adding some Hyperloop Components.</p>

<p>Either way you are going to need to import Javascript components into the Hyperloop namespace. Hyperloop provides both manual and automatic mechanisms to do this depending on the level of control you need.</p>

<h4 id="importing-components">Importing Components</h4>

<p>Lets say you have an existing React Component written in javascript that you would like to access from Hyperloop.  </p>

<p>Here is a simple hello world component:</p>
<pre class="highlight javascript"><code><span class="nb">window</span><span class="p">.</span><span class="nx">SayHello</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="na">displayName</span><span class="p">:</span> <span class="s2">"SayHello"</span><span class="p">,</span>
  <span class="na">render</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">"div"</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="s2">"Hello "</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre>
<p>Assuming that this component is loaded some place in your assets, you can then access this from Hyperloop by creating a wrapper Component:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">SayHello</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">imports</span> <span class="s1">'SayHello'</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">MyBigApp</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">render</span><span class="p">(</span><span class="no">DIV</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># SayHello will now act like any other Hyperloop component</span>
    <span class="no">SayHello</span> <span class="ss">name: </span><span class="s1">'Matz'</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>The <code>imports</code> directive takes a string (or a symbol) and will simply evaluate it and check to make sure that the value looks like a React component, and then set the underlying native component to point to the imported component.</p>

<h4 id="importing-libraries">Importing Libraries</h4>

<p>Many React components come in libraries.  The <code>ReactBootstrap</code> library is one example.  You can import the whole library at once using the <code>React::NativeLibrary</code> class.  Assuming that you have initialized <code>ReactBootstrap</code> elsewhere, this is how you would bring it into Hyperloop.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">RBS</span> <span class="o">&lt;</span> <span class="no">React</span><span class="o">::</span><span class="no">NativeLibrary</span>
  <span class="n">imports</span> <span class="s1">'ReactBootstrap'</span>
<span class="k">end</span>
</code></pre>
<p>We can now access our bootstrap components as components defined within the RBS scope:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Show</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>

  <span class="k">def</span> <span class="nf">say_hello</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">alert</span> <span class="s2">"Hello from number </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="n">render</span> <span class="no">RBS</span><span class="o">::</span><span class="no">Navbar</span><span class="p">,</span> <span class="ss">bsStyle: :inverse</span> <span class="k">do</span>
    <span class="no">RBS</span><span class="o">::</span><span class="no">Nav</span><span class="p">()</span> <span class="k">do</span>
      <span class="no">RBS</span><span class="o">::</span><span class="no">NavbarBrand</span><span class="p">()</span> <span class="k">do</span>
        <span class="no">A</span><span class="p">(</span><span class="ss">href: </span><span class="s1">'#'</span><span class="p">)</span> <span class="p">{</span> <span class="s1">'Hyperloop Showcase'</span> <span class="p">}</span>
      <span class="k">end</span>
      <span class="no">RBS</span><span class="o">::</span><span class="no">NavDropdown</span><span class="p">(</span><span class="ss">eventKey: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">title: </span><span class="s1">'Things'</span><span class="p">,</span> <span class="ss">id: :drop_down</span><span class="p">)</span> <span class="k">do</span>
        <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="nf">.</span><span class="mi">5</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
          <span class="no">RBS</span><span class="o">::</span><span class="no">MenuItem</span><span class="p">(</span><span class="ss">href: </span><span class="s1">'#'</span><span class="p">,</span> <span class="ss">key: </span><span class="n">n</span><span class="p">,</span> <span class="ss">eventKey: </span><span class="s2">"1.</span><span class="si">#{</span><span class="n">n</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="k">do</span>
            <span class="s2">"Number </span><span class="si">#{</span><span class="n">n</span><span class="si">}</span><span class="s2">"</span>
          <span class="k">end</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="ss">:click</span><span class="p">)</span> <span class="p">{</span> <span class="n">say_hello</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Besides the <code>imports</code> directive, <code>React::NativeLibrary</code> also provides a rename directive that takes pairs in the form <code>oldname =&gt; newname</code>.  For example:</p>
<pre class="highlight ruby"><code>  <span class="n">rename</span> <span class="s1">'NavDropdown'</span> <span class="o">=&gt;</span> <span class="s1">'NavDD'</span><span class="p">,</span> <span class="s1">'Navbar'</span> <span class="o">=&gt;</span> <span class="s1">'NavBar'</span><span class="p">,</span> <span class="s1">'NavbarBrand'</span> <span class="o">=&gt;</span> <span class="s1">'NavBarBrand'</span>
</code></pre>
<p><code>React::NativeLibrary</code> will import components that may be deeply nested in the library.  For example consider a component was defined as <code>MyLibrary.MySubLibrary.MyComponent</code>:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">MyLib</span> <span class="o">&lt;</span> <span class="no">React</span><span class="o">::</span><span class="no">NativeLibrary</span>
  <span class="n">imports</span> <span class="s1">'MyLibrary'</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">App</span> <span class="o">&lt;</span> <span class="no">React</span><span class="o">::</span><span class="no">NativeLibrary</span>
  <span class="n">render</span> <span class="k">do</span>  
    <span class="p">.</span><span class="nf">.</span><span class="o">.</span>
    <span class="no">MyLib</span><span class="o">::</span><span class="no">MySubLibrary</span><span class="o">::</span><span class="no">MyComponent</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
    <span class="nf">.</span><span class="p">.</span><span class="nf">.</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Note that the <code>rename</code> directive can be used to rename both components and sublibraries, giving you full control over the ruby names of the components and libraries.</p>

<h4 id="auto-import">Auto Import</h4>

<p>If you use a lot of libraries and are using a Javascript tool chain with Webpack, having to import the libraries in both Hyperloop and Webpack is redundant and just hard work.</p>

<p>Instead you can opt-in for <em>auto importing</em> Javascript components into Hyperloop as you need them.  Simply <code>require hyper-react/auto-import</code> immediately after you <code>require hyper-react</code>.  </p>

<p>Now you do not have to use component <code>imports</code> directive or <code>React::NativeLibrary</code> unless you need to rename a component.</p>

<p>In Ruby all module and class names normally begin with an uppercase letter.  However in Javascript this is not always the case, so the auto import will first try the Javascript name that exactly matches the Ruby name, and if that fails it will try the same name with the first character downcased.  For example</p>

<p><code>MyComponent</code> will first try <code>MyComponent</code> in the Javascript name space, then <code>myComponent</code>.</p>

<p>Likewise MyLib::MyComponent would match any of the following in the Javascript namespace: <code>MyLib.MyComponent</code>, <code>myLib.MyComponent</code>, <code>MyLib.myComponent</code>, <code>myLib.myComponent</code></p>

<p><em>How it works:  The first time Ruby hits a native library or component name, the constant value will not be defined.  This will trigger a lookup in the javascript name space for the matching component or library name.  This will generate either a new subclass of Hyperloop::Component or React::NativeLibrary that imports the javascript object, and no further lookups will be needed.</em></p>

<h4 id="including-react-source">Including React Source</h4>

<p>If you are in the business of importing components with a tool like Webpack, then you will need to let Webpack (or whatever dependency manager you are using) take care of including the React source code.  Just make sure that you are <em>not</em> including it on the ruby side of things. Hyperloop is currently tested with React versions 13, 14, and 15, so its not sensitive to the version you use.</p>

<p>However it gets a little tricky if you are using the react-rails gem.  Each version of this gem depends on a specific version of React, and so you will need to manually declare this dependency in your Javascript dependency manager.  Consult this <a href="https://github.com/reactjs/react-rails/blob/master/VERSIONS.md">table</a> to determine which version of React you need. For example assuming you are using <code>npm</code> to install modules and you are using version 1.7.2 of react-rails you would say something like this:</p>
<pre class="highlight shell"><code>npm install react@15.6.2 react-dom@15.6.2 --save
</code></pre>
<p>See <a href="/tutorials/hyperlooprails/webpack/">{ NPM and Webpack Tutorial }</a> or <a href="/tutorials/hyperlooprails/hyperloop-rails-webpackergem-helloworld/">{ Webpacker GEM Tutorial }</a> for more information.</p>

<h4 id="using-webpack">Using Webpack</h4>

<p>Just a word on Webpack: If you a Ruby developer who is new to using Javascript libraries then we recommend using Webpack to manage javascript component dependencies.  Webpack is essentially bundler for Javascript. Please see our Tutorials section for more information.</p>

<p>There are also good tutorials on integrating Webpack with existing rails apps a google search away.</p>

<h3 id="server-side-rendering-or-prerendering">Server-side rendering (or Prerendering)</h3>

<p><strong>Prerendering is controllable at three levels:</strong></p>

<ul>
<li>In the rails hyperloop initializer you can say:</li>
</ul>
<pre class="highlight ruby"><code> <span class="no">Hyperloop</span><span class="p">.</span><span class="nf">configuration</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
   <span class="n">config</span><span class="p">.</span><span class="nf">prerendering</span> <span class="o">=</span> <span class="ss">:off</span> <span class="c1"># :on by default</span>
 <span class="k">end</span>
</code></pre>
<ul>
<li>In a route you can override the config setting by setting a default for hyperloop_prerendering:</li>
</ul>
<pre class="highlight ruby"><code><span class="n">get</span> <span class="s1">'/some_page'</span><span class="p">,</span> <span class="ss">to: </span><span class="s1">'hyperloop#some_page'</span><span class="p">,</span> <span class="ss">defaults: </span><span class="p">{</span><span class="ss">hyperloop_prerendering: :off</span><span class="p">}</span> <span class="c1"># or :on</span>
</code></pre>
<p>This allows you to override the prerendering option for specific pages. For example the application may have prererendering off by default (via the config setting) but you can still turn it on for a specific page.</p>

<ul>
<li>You can override the route, and config setting using the hyperloop-prerendering query param:</li>
</ul>
<pre class="highlight html"><code>http://localhost:3000/my_hyper_app/some_page?hyperloop-prerendering=off
</code></pre>
<p>This is useful for development and testing</p>

<p>NOTE: in the route you say hyperloop_prererendering but in the query string its hyperloop-prerendering (underscore vs. dash). This is because of rails security protection when using defaults.</p>

<h3 id="further-reading">Further Reading</h3>

<p><strong>Note:</strong> The Hyperloop gems have recently been renamed. The links below will take you to the correct Github projects but you might find the name of the project does not quite match the name of the gem on this page. Hyperloop Components were previously known as HyperReact or Reactrb.</p>

<h4 id="other-hyperloop-tutorials-and-examples">Other Hyperloop tutorials and examples</h4>

<ul>
<li><a href="http://ruby-hyperloop.io/tutorials/">Hyperloop Tutorials</a></li>
</ul>

<h4 id="react-under-the-covers">React under the covers</h4>

<p>Hyperloop Components and friends are in most cases simple DSL Ruby wrappers to the underlying native JavaScript libraries and React Components. It is really important to have a solid grip on how these technologies work to complement your understanding of Hyperloop. Most searches for help on Google will take you to examples written in JSX or ES6 JavaScript but you will learn over time to translate this to Hyperloop equivalents. To make headway with Hyperloop you do need a solid understanding of the underlying philosophy of React and its component based architecture. The &#39;Thinking in React&#39; tutorial below is an excellent place to start.</p>

<ul>
<li><a href="https://facebook.github.io/react/docs/thinking-in-react.html">Thinking in React</a></li>
<li><a href="https://facebook.github.io/react/docs/getting-started.html">React</a></li>
<li><a href="https://github.com/reactjs/react-router">React Router</a></li>
</ul>

<h4 id="opal-under-the-covers">Opal under the covers</h4>

<p>Hyperloop Components are a DSL wrapper of React which uses Opal to compile Ruby code to ES5 native JavaScript. If you have not used Opal before then you should at a minimum read the excellent guides as they will teach you enough Opal to get you started with Hyperloop.</p>

<ul>
<li><a href="http://opalrb.org/">Opal</a></li>
<li><a href="http://opalrb.org/docs/guides/v0.9.2/index.html">Opal Guides</a></li>
<li><a href="https://www.youtube.com/watch?v=vhIrrlcWphU">To see the full power of Opal in action watch this video</a></li>
</ul>

        </div>
      </div>
    </div>

    <div class="page-footer-upperline">
      <div class="container">

      </div>
    </div>

    <footer class="nav-footer">
  <section class="sitemap">

    <a href="/" class="nav-home"></a>

    <div>
      <h6><a href="/start/components" class="hyperloop-white">Start</a></h6>
      <a href="/start/components">Components</a>
      <a href="/start/stores">Stores</a>
      <a href="/start/models">Models</a>
      <a href="/start/operations">Operations</a>
      <a href="/start/policies">Policies</a>
      <a href="/start/pragmatic">Pragmatic Thinking</a>
    </div>
    <div>


      <h6><a href="/tutorials" class="hyperloop-white">Tutorials</a></h6>
      <a href="/tutorials/hyperloopcomps">Hyperloop COMPS</a>
      <a href="/tutorials/hyperloopjs">Hyperloop.js</a>
      <a href="/tutorials/hyperlooprails">Hyperloop and Rails</a>
      <a href="/tutorials/hyperloopdeploy">Hyperloop deployment</a>
      <a href="/tutorials/opal">Opal</a>
      <a href="/tutorials/videos">Videos</a>
    </div>
    <div>
      <h6><a href="/installation" class="hyperloop-white">Installation</a></h6>
      <a href="/installation#opal-playground">Hyperloop.js</a>
  	  <a href="/installation#ror">With Ruby On Rails</a>
  	  <a href="/installation#with-sinatra">With Sinatra</a>
  	  <a href="/installation#deployment">Deployment</a>
    </div>
    <div>
      <h6><a href="/gems" class="hyperloop-white">Gems</a></h6>
      <a href="https://github.com/ruby-hyperloop/hyperloop">hyperloop</a>
      <a href="https://github.com/ruby-hyperloop/hyperloop-js">hyperloop-js</a>
      <a href="https://github.com/ruby-hyperloop/hyper-react">hyper-component</a>
      <a href="https://github.com/ruby-hyperloop/hyper-store">hyper-store</a>
      <a href="https://github.com/ruby-hyperloop/hyper-mesh">hyper-model</a>
      <a href="https://github.com/ruby-hyperloop/hyper-operation">hyper-operation</a>
      <a href="https://github.com/ruby-hyperloop/reactrb-router/tree/v2-4-0">hyper-router</a>
      <a href="https://github.com/ruby-hyperloop/hyper-spec">hyper-spec</a>
      <a href="https://github.com/ruby-hyperloop/hyper-trace">hyper-trace</a>
    </div>
    <div>
      <h6><a href="/tools" class="hyperloop-white">Tools</a></h6>
      <a href="#testing">Testing</a>
    	<a href="#tools">Tools</a>
    	<a href="#debugging">Debugging</a>
    </div>
    <div>
      <h6><a href="/docs/architecture" class="hyperloop-white">Docs</a></h6>
      <a href="/docs/architecture">Architecture</a>
      <a href="/docs/components/docs#components-dsl-overview">Components</a>
      <a href="/docs/stores/docs">Stores</a>
      <a href="/docs/models/docs">Models</a>
      <a href="/docs/operations/docs">Operations</a>
      <a href="/docs/policies/docs">Policies</a>
    </div>

  </section>

  <section class="otherlinks">
    <a href="https://github.com/ruby-hyperloop" class="hyperloop-white">Github</a>
    <a href="/support" class="hyperloop-white">Help</a>
    <a href="/blog" class="hyperloop-white">Blog</a>
  </section>

  <section class="copyright">
    Copyright © 2018 Hyperloop.
  </section>
</footer>


    <script>
      (function(Opal) {
        var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;
        Opal.add_stubs(['$puts']);
        return self.$puts("Opal ok")
      })(Opal);
    </script>

    <!-- <script   src="http://code.jquery.com/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script> -->


    <script type="text/ruby">puts "Hyperloop JS ok"</script>

    


  </body>
</html>
