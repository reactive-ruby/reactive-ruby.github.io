<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <meta name="google-site-verification" content="qjqVOvRhHfsuDbLOvaAnj2mkUZJ9Xwzg84TMVXduvUc" />

    <meta charset="UTF-8">
    <title>Hyperloop</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script src="https://unpkg.com/react@15/dist/react.min.js"></script>
    <script src="https://unpkg.com/react-dom@15/dist/react-dom.min.js"></script>

    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.5/marked.min.js"></script>


    <!-- Opal and Hyperloop -->
    <script src="http://cdn.opalrb.org/opal/current/opal.min.js"></script>
    <script src="https://rawgit.com/ruby-hyperloop/hyperloop-js/master/dist/opal.min.js"></script>
    <script src="https://rawgit.com/ruby-hyperloop/hyperloop-js/master/dist/hyperloop.min.js"></script>
    <script src="https://rawgit.com/ruby-hyperloop/hyperloop-js/master/dist/hyperloop-compiler.min.js"></script>


    <!-- If you want local copies... -->
    <!-- <script src="../../../javascripts/opal-compiler.js"></script> -->
    <!-- <script src="../../../javascripts/hyperloop.js"></script> -->

    <script src="https://npmcdn.com/tether@1.2.4/dist/js/tether.min.js"></script>

    <script src="../../../javascripts/bootstrap.min.js"></script>
    <script src="../../../javascripts/codemirror.js"></script>
    <script src="../../../javascripts/ruby.js"></script>
    <script src="../../../javascripts/matchbrackets.js"></script>
    <script src="../../../javascripts/react_player.js"></script>
    <script src="../../../javascripts/highlight.pack.js"></script>


    <!-- Components are compiled by Hyperloop Express -->
    <script type="text/ruby">

class CodeMirror < Hyperloop::Component
  param :code, type: String
  param :heading, default: "Code"
  param :rows, type: Integer, default: 0
  param :top_level_component, type: String

  before_mount do
    r=rand(2**256).to_s(36)[0..7]
    @div_code = "code_#{r}"
    @div_result = "result_#{r}"
  end

  after_mount do
  # puts params.code
    @editor = `CodeMirror(document.getElementById(#{@div_code}), {
      value: #{params.code.to_s},
      mode: 'text/x-ruby',
      matchBrackets: true,
      lineNumbers: false,
      indentUnit: 2,
      theme: 'github'
    });`

    `#{@editor}.on('change', #{lambda {on_change} })`
    `#{@editor}.setSize(null, #{@editor}.defaultTextHeight()*#{params.rows})` unless params.rows == 0
    execute_code
  end

  render(DIV) do
    div.card {
      div.card_header { params.heading }
      div(id: @div_code)
      div.card_header do
        img(src: '../../../images/hyperloop-logo-small-white.png' , width:'25')
        span { ' ' }
        'Live editor results'
      end
      div.card_block(id: @div_result)
    }
  end

  def on_change
    execute_code
  end

  def execute_code
    begin
      code = `#{@editor}.getValue()`
      # puts code
      code += "\nElement['##{@div_result}'].render(#{params.top_level_component})"
      compiled_code = Opal::Compiler.new(code).compile

      `ReactDOM.unmountComponentAtNode(document.getElementById(#{@div_result}));`

      # Dispatchers and Receivers example works but Steps example breaks
      # Hyperloop::Context.reset!
      # `eval(#{compiled_code})`
      # Hyperloop::Application::Boot.run()

      # Steps example works but Dispatchers and Receivers example breaks
      `eval(#{compiled_code})`
      Hyperloop::Context.reset!
      Hyperloop::Application::Boot.run()

      component = Module.const_get params.top_level_component
      # we need to see if the component is valid - try checking if it can render static markup
      # the following line generates: `undefined method to_n for SimpleComponent`
      # if React.render_to_static_markup( component ).empty?
      #   invalid_component_message
      # end
    rescue Exception => e
      @time_out = after(0.1) do
        unable_to_compile_message e.message
      end
    end
  end

  def invalid_component_message
    message = div.text_danger do
      h3.text_danger {"Oops, invalid Component..."}
      p { "Your Component has been rejected by React. A valid Component must have a render macro and return just one HTML element." }
    end
    Element["##{@div_result}"].render{ message }
  end

  def unable_to_compile_message reason
    message = div.text_danger do
      h3.text_danger {"Can't compile..."}
      p { reason }
    end
    Element["##{@div_result}"].render{ message }
  end

end

</script>

    <script type="text/ruby">

Document.ready? do
   Element.find('div.codemirror-live-edit').each do |mount_point|
     heading = mount_point.attr('data-heading')
     rows = mount_point.attr('data-rows')
     top_level_component = mount_point.attr('data-top-level-component')
     code = Element[mount_point].find('pre').text.strip
     params = {code: code, top_level_component: top_level_component}
     params = params.merge({heading: heading}) if heading
     params = params.merge({rows: rows.to_i}) if rows
     codemirror_component = Object.const_get('CodeMirror')
     React.render(React.create_element(codemirror_component, params ), mount_point)
   end
end

</script>


    <script type="text/ruby">

class ToggleCodemirror < Hyperloop::Component
  param :code, type: String
  param :heading, default: "Code"
  param :rows, type: Integer, default: 0
  param :top_level_component, type: String
  param :show_code

  before_mount do
    r=rand(2**256).to_s(36)[0..7]
    @div_code = "code_#{r}"
    @div_result = "result_#{r}"
  end

  after_mount do
  # puts params.code
    @editor = `CodeMirror(document.getElementById(#{@div_code}), {
      value: #{params.code.to_s},
      mode: 'text/x-ruby',
      matchBrackets: true,
      lineNumbers: false,
      indentUnit: 2,
      readOnly: true,
      theme: 'github'
    });`

    `#{@editor}.setSize(null, #{@editor}.defaultTextHeight()*#{params.rows})` unless params.rows == 0

    Element['.codediv'].hide('')
    mutate.show_code false
    
  end

  render(DIV) do
    div.card {
      div.card_header do
        div(class: 'row') do
          div(class: 'col-md-6') do
            img(src: '../../../images/hyperloop-logo-small-white.png' , width:'25') 
            span { ' ' }
            span { params.heading }
          end
          div(class: 'col-md-6 align-right') do

            toggle_link
          end
        end
      end

      div(id: @div_code, class: 'codediv') 
    }
  end

  def toggle_link
    
      BUTTON(class: 'btn btn-info btn-sm') do
        state.show_code ? "Click to hide code" : "Click to show code"
      end.on(:click) do |ev|
        mutate.show_code !state.show_code 
        state.show_code ? Element["##{@div_code}"].show('') : Element["##{@div_code}"].hide('')
      end
    
  end

 
end

</script>

    <script type="text/ruby">

Document.ready? do
    Element.find('div.togglecode').each do |mount_point|
        heading = mount_point.attr('data-heading')
        rows = mount_point.attr('data-rows')
        top_level_component = mount_point.attr('data-top-level-component')
        code = Element[mount_point].find('pre').text.strip
        params = {code: code, top_level_component: top_level_component}
        params = params.merge({heading: heading}) if heading
        params = params.merge({rows: rows.to_i}) if rows
        codemirror_component = Object.const_get('ToggleCodemirror')
        React.render(React.create_element(codemirror_component, params ), mount_point)
    end
end

</script>

    <link href="../../../stylesheets/bootstrap.min.css" rel="stylesheet" />
    <link href="../../../stylesheets/typography.css" rel="stylesheet" />
    <link href="../../../stylesheets/override.css" rel="stylesheet" />
    <link href="../../../stylesheets/divtable.css" rel="stylesheet" />
    <!-- <link href="../../../stylesheets/code.css" rel="stylesheet" /> -->
    <link href="../../../stylesheets/github.css" rel="stylesheet" />
    <link href="../../../stylesheets/highlighting.css" rel="stylesheet" />
    <link href="../../../stylesheets/codemirror.css" rel="stylesheet" />
    <link href="../../../stylesheets/monokai-sublime.css" rel="stylesheet" />

    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />

    <!-- Favicons -->

    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="../../../images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="../../../images/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/images/manifest.json">
    <link rel="mask-icon" href="../../../images/safari-pinned-tab.svg" color="#e81176">
    <meta name="theme-color" content="#ffffff">

  </head>

  <body>
    <div class="navbarbackgroundcolor">
      <div class="container">
        <nav class="navbar navbar-ligh">
  <button class="navbar-toggler hidden-sm-up" type="button" data-toggle="collapse" data-target="#exCollapsingNavbar2" aria-controls="exCollapsingNavbar2" aria-expanded="false" aria-label="Toggle navigation">
    &#9776;
  </button>
  <div class="collapse navbar-toggleable-xs" id="exCollapsingNavbar2">
    <ul class="nav navbar-nav">
      <li class="nav-item">
        <a href="/" class="nav-link"><span class='navfirstletter'>H</span>yperloop</a>
      </li>
      <li class="nav-item">
        <a href="/start/components" class="nav-link active"><span class='navfirstletter'>S</span>tart</a>
      </li>
      <li class="nav-item">
        <a href="/installation" class="nav-link"><span class='navfirstletter'>I</span>nstallation</a>
      </li>
      <li class="nav-item">
        <a href="/tutorials" class="nav-link"><span class='navfirstletter'>T</span>utorials</a>
      </li>
      <li class="nav-item">
        <a href="/gems" class="nav-link"><span class='navfirstletter'>G</span>ems</a>
      </li>
      <li class="nav-item">
        <a href="https://github.com/ruby-hyperloop" class="nav-link"><span class='navfirstletter'>G</span>ithub</a>
      </li>
      <li class="nav-item">
        <a href="/tools" class="nav-link"><span class='navfirstletter'>T</span>ools</a>
      </li>
      <li class="nav-item">
        <a href="/docs/architecture" class="nav-link"><span class='navfirstletter'>D</span>ocs</a>
      </li>
      <li class="nav-item">
        <a href="/help" class="nav-link"><span class='navfirstletter'>H</span>elp</a>
      </li>
      <li class="nav-item">
        <a href="/blog" class="nav-link"><span class='navfirstletter'>B</span>log</a>
      </li>
      <!-- <li class="nav-item">
        <input type="text" name="search" />
      </li> -->
    </ul>
  </div>
</nav>

      </div>
    </div>





    <div class="jumbotron page-header">
      <div class="container">

        <div class="row hidden-sm-down">
          <div class="col-md-2">
            <div class="hyperlooplogo">
            </div>
          </div>
          <div class="col-md-8">

            <h1 class="display-4 project-name">Hyperloop</h1>

            <h4 class="display-7 project-tagline">

              The Complete Isomorphic Ruby Framework
            </h4>
          </div>

        </div>

        <div class="row hidden-md-up">
          <div class="col-md-3">
            <div class="hyperlooplogo">
            </div>
          </div>
          <div class="col-md-9">
            <h1 class="h1 project-name center-text">Hyperloop</h1>
            </br>
            <h2 class="h5 project-tagline center-text">
              The Complete Isomorphic Ruby Framework
            </h2>
          </div>

        </div>


      </div>
    </div>

    <div class="page-header-underline">
      <div class="container">

      </div>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-md-3 sidenavcol">
          
      <ul class="nav">
        <li class="nav-item"><a href="/docs/architecture">Hyperloop Architecture</a></li>
      </ul>

  <br>


    <ul class="nav">
      <li class="nav-item"><a href="/docs/components/docs">Hyperloop Components</a></li>
    </ul>


  <br>

    <ul class="navtoc">
<li class="navtoc-item">
<a href="#hyperloop-stores">Hyperloop Stores</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#reading-and-mutating-states">Reading and Mutating States</a>
<ul class="navtoc">
<li class="navtoc-item">
<ul class="navtoc">
<li class="navtoc-item">
<a href="#initializing-states">Initializing States</a>
</li>
<li class="navtoc-item">
<a href="#reading-states">Reading States</a>
</li>
<li class="navtoc-item">
<a href="#mutating-states">Mutating States</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#instances-and-classes">Instances and Classes</a>
</li>
<li class="navtoc-item">
<a href="#states-and-promises">States and Promises</a>
</li>
<li class="navtoc-item">
<a href="#explicitly-declaring-states">Explicitly Declaring States</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#receiving-operation-dispatches">Receiving Operation Dispatches</a>
</li>
</ul>
</li>
</ul>


  <br>

    <ul class="nav">
      <li class="nav-item"><a href="/docs/router/docs">Hyperloop Router</a></li>
    </ul>

  <br>

    <ul class="nav">
      <li class="nav-item"><a href="/docs/models/docs">Hyperloop Models</a></li>
    </ul>

  <br>

   <ul class="nav">
      <li class="nav-item"><a href="/docs/operations/docs">Hyperloop Operations</a></li>
  </ul>

  <br>


    <ul class="nav">
      <li class="nav-item"><strong><a href="/docs/policies/docs">Hyperloop Policies</a></strong></li>
    </ul>



          <br>
        </div>
        <div class="col-md-9 main-content">
          <h1 id="hyperloop-stores">Hyperloop Stores</h1>

<p>Hyperloop <strong>Stores</strong> are implemented in the <strong>HyperStore Gem</strong>.</p>

<p>Stores are where the state of your Application lives. Anything but a completely static web page will have dynamic states that change because of user inputs, the passage of time, or other external events.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserStore</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Store</span>
  <span class="n">state</span> <span class="ss">:current</span><span class="p">,</span> <span class="ss">scope: :class</span><span class="p">,</span> <span class="ss">reader: </span><span class="kp">true</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">set_current!</span> <span class="n">user</span>
    <span class="n">mutate</span><span class="p">.</span><span class="nf">current</span> <span class="n">user</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># to access the store</span>
<span class="no">UserStore</span><span class="p">.</span><span class="nf">set_current!</span> <span class="n">user</span>
<span class="no">UserStore</span><span class="p">.</span><span class="nf">current_user</span>
</code></pre>
<p><strong>Stores are Ruby classes that keep the dynamic parts of the state in special state variables</strong></p>

<ul>
<li><code>Hyperloop::Store::Mixin</code> can be mixed in to any class to turn it into a Flux Store.</li>
<li>You can also create Stores by subclassing <code>Hyperloop::Store</code>.</li>
<li>Stores are built out of <em>reactive state variables</em>.</li>
<li>Components that <em>read</em> a Store&#39;s state will <strong>automatically</strong> update when the state changes.</li>
<li>All of your <strong>shared</strong> reactive state should be Stores - <em>The Store is the Truth</em>!</li>
<li>Stores can <em>receive</em> <strong>dispatches</strong> from <em>Operations</em></li>
</ul>

<h2 id="reading-and-mutating-states">Reading and Mutating States</h2>

<p>A Store will have one or more <em>Reactive State Variables</em> or <em>State</em> for short.  States are read using the <code>state</code> method, and are changed using the <code>mutate</code> method.</p>

<p><code>state.items</code> reads the current value of the state named <code>items</code>.  Hyperloop tracks all reads of state, and mutating those states will trigger a re-render of any Components depending on the current value.</p>

<p><code>mutate.items</code> returns the current value of the state named <code>items</code>, but also tells Hyperloop that the value is changing, and that any Components depending on the current value will have to be re-rendered.</p>

<p>The one thing you must remember to do is use <code>mutate</code> if you intend to update the internal value of a state.  For example if the state contains a hash, and you are updating the Hash&#39;s internal value you would use <code>mutate</code> otherwise the change will go unrecorded.</p>

<h4 id="initializing-states">Initializing States</h4>

<p>To assign a new value to a state use the <code>mutate</code> method and pass a parameter to the state:</p>
<pre class="highlight ruby"><code><span class="n">mutate</span><span class="p">.</span><span class="nf">items</span><span class="p">(</span><span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="o">|</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">})</span>
</code></pre>
<h4 id="reading-states">Reading States</h4>

<p>To read the current value of a state use the <code>state</code> method:</p>
<pre class="highlight ruby"><code><span class="n">state</span><span class="p">.</span><span class="nf">items</span> <span class="c1"># returns current value of items</span>
</code></pre>
<p>Typically a store will have quite a few reader (aka getter) methods that hide the details of the state, allowing the Store&#39;s implementation to change, without effecting the interface.</p>

<h4 id="mutating-states">Mutating States</h4>

<p>Often states hold data structures like arrays, hashes, sets, or other Ruby classes, which may be <em>mutated</em>.  For example when you push a new value onto an array you will mutate it.  The <em>value</em> of the array does not change, but its <em>contents</em> does.  If you are accessing a state with the intent to change its content then use the <code>mutate</code> method:</p>
<pre class="highlight ruby"><code><span class="n">mutate</span><span class="p">.</span><span class="nf">items</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
</code></pre>
<h3 id="instances-and-classes">Instances and Classes</h3>

<p>Stores are often singleton classes.  In an application there is one &#39;cart&#39; for example.</p>

<p>However sometimes you will want to create a class where each instance is a Store.  This is straight forward because if a state is read or mutated in an instance method, then you will be referring to that instance&#39;s copy of the state.</p>
<pre class="highlight ruby"><code><span class="c1"># Each UserStream provides a stream of unique user profiles.</span>
<span class="c1"># Each instance has a single HyperStore state variable called user</span>
<span class="c1"># user will contain a single hash representing the user profile.</span>
<span class="k">class</span> <span class="nc">UserStream</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Store</span>

  <span class="c1"># get another user</span>

  <span class="k">def</span> <span class="nf">get_another!</span>
    <span class="n">mutate</span><span class="p">.</span><span class="nf">user</span> <span class="no">UserStream</span><span class="p">.</span><span class="nf">_select_random_user</span>
  <span class="k">end</span>

  <span class="c1"># extract various attributes from the user hash</span>

  <span class="k">def</span> <span class="nf">user_name</span>
    <span class="n">state</span><span class="p">.</span><span class="nf">user</span><span class="p">[</span><span class="ss">:login</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">user_url</span>
    <span class="n">state</span><span class="p">.</span><span class="nf">user</span><span class="p">[</span><span class="ss">:html_url</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">avatar</span>
    <span class="n">state</span><span class="p">.</span><span class="nf">user</span><span class="p">[</span><span class="ss">:avatar_url</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="n">get_another!</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">_select_random_user</span>
    <span class="c1"># _select_random_user provides a stream of unique user profiles.</span>
    <span class="c1"># It will either return a user profile hash, or a promise of one</span>
    <span class="c1"># to come.</span>

    <span class="c1"># The cache of users to choose from does not have to be an state</span>
    <span class="c1"># variable, so we use plain instance variables.</span>
    <span class="k">return</span> <span class="vi">@users</span><span class="p">.</span><span class="nf">delete_at</span><span class="p">(</span><span class="nb">rand</span><span class="p">(</span><span class="vi">@users</span><span class="p">.</span><span class="nf">length</span><span class="p">))</span> <span class="k">unless</span> <span class="vi">@users</span><span class="p">.</span><span class="nf">blank?</span>
    <span class="c1"># execute the GetMoreUsers Operation to grab another batch of users</span>
    <span class="c1"># if we are not already waiting on a promise</span>
    <span class="vi">@promise</span> <span class="o">=</span> <span class="no">GetMoreUsers</span><span class="p">.</span><span class="nf">then</span> <span class="k">do</span> <span class="o">|</span><span class="n">response</span><span class="o">|</span>
      <span class="vi">@users</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="nf">json</span>
    <span class="k">end</span> <span class="k">if</span> <span class="vi">@promise</span><span class="p">.</span><span class="nf">nil?</span> <span class="o">||</span> <span class="vi">@promise</span><span class="p">.</span><span class="nf">resolved?</span>
    <span class="c1"># wait for the promise to resolve then try again</span>
    <span class="vi">@promise</span><span class="p">.</span><span class="nf">then</span> <span class="p">{</span> <span class="n">_select_random_user</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">GetMoreUsers</span> <span class="o">&lt;</span> <span class="no">HyperOperation</span>
  <span class="k">def</span> <span class="nf">execute</span>
    <span class="no">HTTP</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"https://api.github.com/users?since=</span><span class="si">#{</span><span class="nb">rand</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Stores that have multiple instances will typically have instance methods that directly mutate the store.  We recommend you end these methods with an exclamation (!) to make it clear you are exposing a mutator.</p>

<h3 id="states-and-promises">States and Promises</h3>

<p>The above example is greatly simplified because if a promise is assigned to a state it will not mutate  <em>until the promise resolves</em>.  Combining this with instance Stores gives a powerful way to encapsulate system behavior.</p>

<h3 id="explicitly-declaring-states">Explicitly Declaring States</h3>

<p>States like instance variables are created when they are first referenced.</p>

<p>As a convenience you may also explicitly declare states.  This reduces code noise, and improves readability.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Cart</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Store</span>
  <span class="n">state</span> <span class="ss">items: </span><span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="o">|</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">},</span> <span class="ss">scope: :class</span><span class="p">,</span> <span class="ss">reader: </span><span class="kp">true</span>
<span class="k">end</span>
</code></pre>
<p>This <em>declares</em> the <code>items</code> state as a class state variable, will initialize it with the hash on <code>Hyperloop::Boot</code>, and provides a reader method.
That is 6 lines of code for the price of 1, plus now the intention of <code>items</code> is clearly defined.</p>

<p>The <code>state</code> declaration has the following flavors, depending on how the state is to be initialized:</p>
<pre class="highlight ruby"><code>  <span class="n">state</span> <span class="ss">:items</span><span class="p">,</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span> <span class="nf">other</span> <span class="n">options</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="c1"># items will be initialized to nil</span>
  <span class="n">state</span> <span class="ss">items: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span> <span class="nf">other</span> <span class="n">options</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="c1"># items will be initialized to the array [1, 2, 3]</span>
  <span class="n">state</span> <span class="ss">:items</span><span class="p">,</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span> <span class="nf">other</span> <span class="n">options</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span> <span class="nf">do</span>
    <span class="p">.</span><span class="nf">.</span><span class="p">.</span> <span class="nf">compute</span> <span class="n">initial</span> <span class="n">value</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
    <span class="nf">.</span><span class="p">.</span><span class="nf">.</span> <span class="n">context</span> <span class="n">will</span> <span class="n">be</span> <span class="n">either</span> <span class="n">the</span> <span class="k">class</span> <span class="n">an</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
    <span class="nf">.</span><span class="p">.</span><span class="nf">.</span> <span class="n">instance</span> <span class="n">depending</span> <span class="n">on</span> <span class="n">the</span> <span class="n">scope</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">end</span>
</code></pre>
<p>Other options to the <code>state</code> declaration are:</p>

<ul>
<li><code>scope:</code> either <code>:class</code>, <code>:instance</code>, <code>:shared</code>.  Details below!</li>
<li><code>reader:</code> either <code>true</code>, or a symbol used to declare a reader (getter) method.</li>
<li><code>initializer:</code> either a Proc or a Symbol (indicating a method), to be used to initialize the state.</li>
</ul>

<p>The value of the <code>scope</code> option determines where the state resides.</p>

<ul>
<li>A class state has one instance per class and is directly accessible in class methods, and indirectly in instances using <code>self.class.state</code>.</li>
<li>An instance state has a different copy in each instance of the class, and is not accessible by class methods.</li>
<li>A shared state is like a class state, but is also directly accessible in instances.</li>
</ul>

<p>The default value for <code>scope:</code> depends on where the state is declared:</p>
<pre class="highlight ruby"><code>  <span class="n">state</span> <span class="ss">:items</span> <span class="c1"># declares an instance state variable, each instance gets its own state</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="n">state</span> <span class="ss">:items</span> <span class="c1"># declares a class instance state variable</span>
  <span class="k">end</span>
</code></pre>
<p>In the above example there is one class instance state named <code>items</code> and an additional state variable also called
items for each instance.</p>

<p>The <code>shared</code> option just makes it easier to access a class state from instances.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">MyStore</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Store</span>
  <span class="n">state</span> <span class="ss">:shared_state</span><span class="p">,</span> <span class="ss">scope: :shared</span>
  <span class="n">state</span> <span class="ss">:class_state</span><span class="p">,</span> <span class="ss">scope: :class</span>
  <span class="n">state</span> <span class="ss">:instance_state</span> <span class="c1"># scope: :instance is default here</span>

  <span class="k">def</span> <span class="nf">instance_method</span>
    <span class="c1"># shared state makes class states easy to access</span>
    <span class="n">state</span><span class="p">.</span><span class="nf">shared_state</span>
    <span class="c1"># without shared state class_state is still accessible</span>
    <span class="c1"># with more typing</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">class_state</span>
    <span class="c1"># each instance gets its own copy of instance states</span>
    <span class="n">state</span><span class="p">.</span><span class="nf">instance_state</span>
    <span class="c1"># attempt to access a declared state variable out of context</span>
    <span class="c1"># results in an error!</span>
    <span class="n">state</span><span class="p">.</span><span class="nf">class_state</span> <span class="c1"># exception!</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">class_method</span>
    <span class="c1"># this is the same state as was referenced in instance_method</span>
    <span class="n">state</span><span class="p">.</span><span class="nf">shared_state</span>
    <span class="c1"># and so is this</span>
    <span class="n">state</span><span class="p">.</span><span class="nf">class_state</span>
    <span class="c1"># and this will raise an exception</span>
    <span class="n">state</span><span class="p">.</span><span class="nf">instance_state</span>
  <span class="k">end</span>
</code></pre>
<p>Class state variables are initialized by an implicit <code>Hyperloop::Application::Boot</code> receiver.  If an initial value is directly provided (not via a proc, method or block) then the value will be <code>dup</code>ed when the second and following Boot dispatches are received.  The proc, method or block initializers will run in the context of the class, and the state variable will be available.  For example:</p>
<pre class="highlight ruby"><code><span class="n">state</span> <span class="ss">:boot_counter</span><span class="p">,</span> <span class="ss">scope: :shared</span> <span class="k">do</span>
  <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="nf">boot_counter</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
<span class="k">end</span>

<span class="c1"># more practically perhaps:</span>

<span class="n">state</span> <span class="ss">:my_state</span><span class="p">,</span> <span class="ss">scope: :shared</span> <span class="k">do</span>
  <span class="n">state</span><span class="p">.</span><span class="nf">my_state</span> <span class="o">||</span> <span class="p">[]</span> <span class="c1"># don't re-initialize me on reboots</span>
<span class="k">end</span>
</code></pre>
<p>Instance variables are initialized when instances of the Store are created.  Each initialization will <code>dup</code> the initial value unless supplied by a proc, method or block.</p>

<p>This initialization behavior will work in most cases but for more control simply leave off any initializer, and write your own.</p>

<p><strong>Note for class states there is a subtle difference between saying:</strong></p>
<pre class="highlight ruby"><code><span class="n">state</span> <span class="ss">my_state: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">scope: :shared</span> <span class="c1"># or :class</span>
<span class="c1"># and</span>
<span class="n">state</span> <span class="ss">:my_state</span><span class="p">,</span> <span class="ss">scope: :shared</span> <span class="c1"># or :class</span>

</code></pre>
<p>In the first case <code>my_state</code> will be re-initialized to nil on every boot, in the second case it will not.</p>

<h2 id="receiving-operation-dispatches">Receiving Operation Dispatches</h2>

<p>Stores can receive Operation dispatches using the receive method.</p>

<p>Here is a simple shopping cart Store that receives Add, Remove and Empty Operations:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Cart</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Store</span>
  <span class="c1"># First we will define the two Operations.</span>
  <span class="c1"># Because these are closely associated with the Cart</span>
  <span class="c1"># we will name space them inside the cart.</span>
  <span class="k">class</span> <span class="nc">Add</span> <span class="o">&lt;</span> <span class="no">HyperOperation</span>
    <span class="n">param</span> <span class="ss">:item</span>
    <span class="n">param</span> <span class="ss">:qty</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Integer</span><span class="p">,</span> <span class="ss">min: </span><span class="mi">1</span>
  <span class="k">end</span>
  <span class="k">class</span> <span class="nc">Remove</span> <span class="o">&lt;</span> <span class="no">HyperOperation</span>
    <span class="n">param</span> <span class="ss">:item</span>
    <span class="n">param</span> <span class="ss">:qty</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Integer</span><span class="p">,</span> <span class="ss">nils: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">min: </span><span class="mi">1</span>
  <span class="k">end</span>
  <span class="k">class</span> <span class="nc">Empty</span> <span class="o">&lt;</span> <span class="no">HyperOperation</span>
  <span class="k">end</span>

  <span class="c1"># The cart's state is represented as a hash, items are the keys, qty is the value</span>
  <span class="c1"># initialize the hash by receiving the system Hyperloop::Application::Boot or Empty dispatches</span>

  <span class="n">receives</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Application</span><span class="o">::</span><span class="no">Boot</span><span class="p">,</span> <span class="no">Empty</span> <span class="k">do</span>
    <span class="n">mutate</span><span class="p">.</span><span class="nf">items</span><span class="p">(</span><span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="o">|</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">})</span>
  <span class="k">end</span>

  <span class="c1"># The stores getter (or reader) method</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">items</span>
    <span class="n">state</span><span class="p">.</span><span class="nf">items</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">empty?</span>
    <span class="n">state</span><span class="p">.</span><span class="nf">items</span><span class="p">.</span><span class="nf">empty?</span>
  <span class="k">end</span>

  <span class="n">receives</span> <span class="no">Add</span> <span class="k">do</span>
    <span class="c1"># notice we use mutate.items since we are modifying the hash</span>
    <span class="n">mutate</span><span class="p">.</span><span class="nf">items</span><span class="p">[</span><span class="n">params</span><span class="p">.</span><span class="nf">item</span><span class="p">]</span> <span class="o">+=</span> <span class="n">params</span><span class="p">.</span><span class="nf">qty</span>
  <span class="k">end</span>

  <span class="n">receives</span> <span class="no">Remove</span> <span class="k">do</span>
    <span class="n">mutate</span><span class="p">.</span><span class="nf">items</span><span class="p">[</span><span class="n">params</span><span class="p">.</span><span class="nf">item</span><span class="p">]</span> <span class="o">-=</span> <span class="n">params</span><span class="p">.</span><span class="nf">qty</span>
    <span class="c1"># remove any items with zero qty from the cart</span>
    <span class="n">mutate</span><span class="p">.</span><span class="nf">items</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="nf">item</span><span class="p">)</span> <span class="k">if</span> <span class="n">state</span><span class="p">.</span><span class="nf">items</span><span class="p">[</span><span class="n">params</span><span class="p">.</span><span class="nf">item</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>This example demonstrates the two ingredients of a Store:</p>

<ul>
<li>Receiving Operation Dispatches and</li>
<li>Reading, and Mutating <em>states</em>.</li>
</ul>

<p>These are explained in detail below.</p>

<p>The <code>receive</code> method takes an list of Operations, and either a symbol (indicating a class method to call), a proc, or a block.</p>

<p>When the dispatch is received the method, proc, or block will be run within the context of the Store&#39;s class (not an instance.)  In addition the <code>params</code> method from the Operation will be available to access the Operations parameters.</p>

<p>The <em>Flux</em> paradigm promotes only mutating state inside of receivers.</p>

<p>Hyperloop is less opinionated.  You may also add mutator methods to your class.  Our recommendation is that you append an exclamation (!) to methods that mutate state.</p>

<p>Note that it is reasonable to have several receivers for the same Operation.  This allows subclassing, mixins, and separation of concerns.</p>

<p>Note also that the Ruby scoping rules make it very reasonable to define the Operations to be received by a Store inside the Store&#39;s scope.  This does not change the semantics of either the Store or the Operation, but simply keeps the name space organized.</p>

        </div>
      </div>
    </div>

    <div class="page-footer-upperline">
      <div class="container">

      </div>
    </div>

    <footer class="nav-footer">
  <section class="sitemap">

    <a href="/" class="nav-home"></a>

    <div>
      <h6><a href="/start/components" class="hyperloop-white">Start</a></h6>
      <a href="/start/components">Components</a>
      <a href="/start/stores">Stores</a>
      <a href="/start/models">Models</a>
      <a href="/start/operations">Operations</a>
      <a href="/start/policies">Policies</a>
      <a href="/start/pragmatic">Pragmatic Thinking</a>
    </div>
    <div>


      <h6><a href="/tutorials" class="hyperloop-white">Tutorials</a></h6>
      <a href="/tutorials/hyperloopcomps">Hyperloop COMPS</a>
      <a href="/tutorials/hyperloopjs">Hyperloop.js</a>
      <a href="/tutorials/hyperlooprails">Hyperloop and Rails</a>
      <a href="/tutorials/hyperloopdeploy">Hyperloop deployment</a>
      <a href="/tutorials/opal">Opal</a>
      <a href="/tutorials/videos">Videos</a>
    </div>
    <div>
      <h6><a href="/installation" class="hyperloop-white">Installation</a></h6>
      <a href="/installation#opal-playground">Hyperloop.js</a>
  	  <a href="/installation#ror">With Ruby On Rails</a>
  	  <a href="/installation#with-sinatra">With Sinatra</a>
  	  <a href="/installation#deployment">Deployment</a>
    </div>
    <div>
      <h6><a href="/gems" class="hyperloop-white">Gems</a></h6>
      <a href="https://github.com/ruby-hyperloop/hyperloop">hyperloop</a>
      <a href="https://github.com/ruby-hyperloop/hyperloop-js">hyperloop-js</a>
      <a href="https://github.com/ruby-hyperloop/hyper-react">hyper-component</a>
      <a href="https://github.com/ruby-hyperloop/hyper-store">hyper-store</a>
      <a href="https://github.com/ruby-hyperloop/hyper-mesh">hyper-model</a>
      <a href="https://github.com/ruby-hyperloop/hyper-operation">hyper-operation</a>
      <a href="https://github.com/ruby-hyperloop/reactrb-router/tree/v2-4-0">hyper-router</a>
      <a href="https://github.com/ruby-hyperloop/hyper-spec">hyper-spec</a>
      <a href="https://github.com/ruby-hyperloop/hyper-trace">hyper-trace</a>
    </div>
    <div>
      <h6><a href="/tools" class="hyperloop-white">Tools</a></h6>
      <a href="#testing">Testing</a>
    	<a href="#tools">Tools</a>
    	<a href="#debugging">Debugging</a>
    </div>
    <div>
      <h6><a href="/docs/architecture" class="hyperloop-white">Docs</a></h6>
      <a href="/docs/architecture">Architecture</a>
      <a href="/docs/components/docs#components-dsl-overview">Components</a>
      <a href="/docs/stores/docs">Stores</a>
      <a href="/docs/models/docs">Models</a>
      <a href="/docs/operations/docs">Operations</a>
      <a href="/docs/policies/docs">Policies</a>
    </div>

  </section>

  <section class="otherlinks">
    <a href="https://github.com/ruby-hyperloop" class="hyperloop-white">Github</a>
    <a href="/support" class="hyperloop-white">Help</a>
    <a href="/blog" class="hyperloop-white">Blog</a>
  </section>

  <section class="copyright">
    Copyright © 2018 Hyperloop.
  </section>
</footer>


    <script>
      (function(Opal) {
        var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;
        Opal.add_stubs(['$puts']);
        return self.$puts("Opal ok")
      })(Opal);
    </script>

    <!-- <script   src="http://code.jquery.com/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script> -->


    <script type="text/ruby">puts "Hyperloop JS ok"</script>




  </body>
</html>
