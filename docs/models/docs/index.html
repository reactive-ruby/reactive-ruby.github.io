<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <meta name="google-site-verification" content="qjqVOvRhHfsuDbLOvaAnj2mkUZJ9Xwzg84TMVXduvUc" />

    <meta charset="UTF-8">
    <title>Hyperloop</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script src="https://unpkg.com/react@15/dist/react.min.js"></script>
    <script src="https://unpkg.com/react-dom@15/dist/react-dom.min.js"></script>

    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.5/marked.min.js"></script>


    <!-- Opal and Hyperloop -->
    <script src="http://cdn.opalrb.org/opal/current/opal.min.js"></script>
    <script src="https://rawgit.com/ruby-hyperloop/hyperloop-js/master/dist/opal.min.js"></script>
    <script src="https://rawgit.com/ruby-hyperloop/hyperloop-js/master/dist/hyperloop.min.js"></script>
    <script src="https://rawgit.com/ruby-hyperloop/hyperloop-js/master/dist/hyperloop-compiler.min.js"></script>


    <!-- If you want local copies... -->
    <!-- <script src="../../../javascripts/opal-compiler.js"></script> -->
    <!-- <script src="../../../javascripts/hyperloop.js"></script> -->

    <script src="https://npmcdn.com/tether@1.2.4/dist/js/tether.min.js"></script>

    <script src="../../../javascripts/bootstrap.min.js"></script>
    <script src="../../../javascripts/codemirror.js"></script>
    <script src="../../../javascripts/ruby.js"></script>
    <script src="../../../javascripts/matchbrackets.js"></script>
    <script src="../../../javascripts/react_player.js"></script>
    <script src="../../../javascripts/highlight.pack.js"></script>


    <!-- Components are compiled by Hyperloop Express -->
    <script type="text/ruby">

class CodeMirror < Hyperloop::Component
  param :code, type: String
  param :heading, default: "Code"
  param :rows, type: Integer, default: 0
  param :top_level_component, type: String

  before_mount do
    r=rand(2**256).to_s(36)[0..7]
    @div_code = "code_#{r}"
    @div_result = "result_#{r}"
  end

  after_mount do
  # puts params.code
    @editor = `CodeMirror(document.getElementById(#{@div_code}), {
      value: #{params.code.to_s},
      mode: 'text/x-ruby',
      matchBrackets: true,
      lineNumbers: false,
      indentUnit: 2,
      theme: 'github'
    });`

    `#{@editor}.on('change', #{lambda {on_change} })`
    `#{@editor}.setSize(null, #{@editor}.defaultTextHeight()*#{params.rows})` unless params.rows == 0
    execute_code
  end

  render(DIV) do
    div.card {
      div.card_header { params.heading }
      div(id: @div_code)
      div.card_header do
        img(src: '../../../images/hyperloop-logo-small-white.png' , width:'25')
        span { ' ' }
        'Live editor results'
      end
      div.card_block(id: @div_result)
    }
  end

  def on_change
    execute_code
  end

  def execute_code
    begin
      code = `#{@editor}.getValue()`
      # puts code
      code += "\nElement['##{@div_result}'].render(#{params.top_level_component})"
      compiled_code = Opal::Compiler.new(code).compile

      `ReactDOM.unmountComponentAtNode(document.getElementById(#{@div_result}));`

      # Dispatchers and Receivers example works but Steps example breaks
      # Hyperloop::Context.reset!
      # `eval(#{compiled_code})`
      # Hyperloop::Application::Boot.run()

      # Steps example works but Dispatchers and Receivers example breaks
      `eval(#{compiled_code})`
      Hyperloop::Context.reset!
      Hyperloop::Application::Boot.run()

      component = Module.const_get params.top_level_component
      # we need to see if the component is valid - try checking if it can render static markup
      # the following line generates: `undefined method to_n for SimpleComponent`
      # if React.render_to_static_markup( component ).empty?
      #   invalid_component_message
      # end
    rescue Exception => e
      @time_out = after(0.1) do
        unable_to_compile_message e.message
      end
    end
  end

  def invalid_component_message
    message = div.text_danger do
      h3.text_danger {"Oops, invalid Component..."}
      p { "Your Component has been rejected by React. A valid Component must have a render macro and return just one HTML element." }
    end
    Element["##{@div_result}"].render{ message }
  end

  def unable_to_compile_message reason
    message = div.text_danger do
      h3.text_danger {"Can't compile..."}
      p { reason }
    end
    Element["##{@div_result}"].render{ message }
  end

end

</script>

    <script type="text/ruby">

Document.ready? do
   Element.find('div.codemirror-live-edit').each do |mount_point|
     heading = mount_point.attr('data-heading')
     rows = mount_point.attr('data-rows')
     top_level_component = mount_point.attr('data-top-level-component')
     code = Element[mount_point].find('pre').text.strip
     params = {code: code, top_level_component: top_level_component}
     params = params.merge({heading: heading}) if heading
     params = params.merge({rows: rows.to_i}) if rows
     codemirror_component = Object.const_get('CodeMirror')
     React.render(React.create_element(codemirror_component, params ), mount_point)
   end
end

</script>


    <script type="text/ruby">

class ToggleCodemirror < Hyperloop::Component
  param :code, type: String
  param :heading, default: "Code"
  param :rows, type: Integer, default: 0
  param :top_level_component, type: String
  param :show_code

  before_mount do
    r=rand(2**256).to_s(36)[0..7]
    @div_code = "code_#{r}"
    @div_result = "result_#{r}"
  end

  after_mount do
  # puts params.code
    @editor = `CodeMirror(document.getElementById(#{@div_code}), {
      value: #{params.code.to_s},
      mode: 'text/x-ruby',
      matchBrackets: true,
      lineNumbers: false,
      indentUnit: 2,
      readOnly: true,
      theme: 'github'
    });`

    `#{@editor}.setSize(null, #{@editor}.defaultTextHeight()*#{params.rows})` unless params.rows == 0

    Element['.codediv'].hide('')
    mutate.show_code false
    
  end

  render(DIV) do
    div.card {
      div.card_header do
        div(class: 'row') do
          div(class: 'col-md-6') do
            img(src: '../../../images/hyperloop-logo-small-white.png' , width:'25') 
            span { ' ' }
            span { params.heading }
          end
          div(class: 'col-md-6 align-right') do

            toggle_link
          end
        end
      end

      div(id: @div_code, class: 'codediv') 
    }
  end

  def toggle_link
    
      BUTTON(class: 'btn btn-info btn-sm') do
        state.show_code ? "Click to hide code" : "Click to show code"
      end.on(:click) do |ev|
        mutate.show_code !state.show_code 
        state.show_code ? Element["##{@div_code}"].show('') : Element["##{@div_code}"].hide('')
      end
    
  end

 
end

</script>

    <script type="text/ruby">

Document.ready? do
    Element.find('div.togglecode').each do |mount_point|
        heading = mount_point.attr('data-heading')
        rows = mount_point.attr('data-rows')
        top_level_component = mount_point.attr('data-top-level-component')
        code = Element[mount_point].find('pre').text.strip
        params = {code: code, top_level_component: top_level_component}
        params = params.merge({heading: heading}) if heading
        params = params.merge({rows: rows.to_i}) if rows
        codemirror_component = Object.const_get('ToggleCodemirror')
        React.render(React.create_element(codemirror_component, params ), mount_point)
    end
end

</script>

    <link href="../../../stylesheets/bootstrap.min.css" rel="stylesheet" />
    <link href="../../../stylesheets/typography.css" rel="stylesheet" />
    <link href="../../../stylesheets/override.css" rel="stylesheet" />
    <link href="../../../stylesheets/divtable.css" rel="stylesheet" />
    <!-- <link href="../../../stylesheets/code.css" rel="stylesheet" /> -->
    <link href="../../../stylesheets/github.css" rel="stylesheet" />
    <link href="../../../stylesheets/highlighting.css" rel="stylesheet" />
    <link href="../../../stylesheets/codemirror.css" rel="stylesheet" />
    <link href="../../../stylesheets/monokai-sublime.css" rel="stylesheet" />

    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />

    <!-- Favicons -->

    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="../../../images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="../../../images/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/images/manifest.json">
    <link rel="mask-icon" href="../../../images/safari-pinned-tab.svg" color="#e81176">
    <meta name="theme-color" content="#ffffff">

  </head>

  <body>
    <div class="navbarbackgroundcolor">
      <div class="container">
        <nav class="navbar navbar-ligh">
  <button class="navbar-toggler hidden-sm-up" type="button" data-toggle="collapse" data-target="#exCollapsingNavbar2" aria-controls="exCollapsingNavbar2" aria-expanded="false" aria-label="Toggle navigation">
    &#9776;
  </button>
  <div class="collapse navbar-toggleable-xs" id="exCollapsingNavbar2">
    <ul class="nav navbar-nav">
      <li class="nav-item">
        <a href="/" class="nav-link"><span class='navfirstletter'>H</span>yperloop</a>
      </li>
      <li class="nav-item">
        <a href="/start/components" class="nav-link active"><span class='navfirstletter'>S</span>tart</a>
      </li>
      <li class="nav-item">
        <a href="/installation" class="nav-link"><span class='navfirstletter'>I</span>nstallation</a>
      </li>
      <li class="nav-item">
        <a href="/tutorials" class="nav-link"><span class='navfirstletter'>T</span>utorials</a>
      </li>
      <li class="nav-item">
        <a href="/gems" class="nav-link"><span class='navfirstletter'>G</span>ems</a>
      </li>
      <li class="nav-item">
        <a href="https://github.com/ruby-hyperloop" class="nav-link"><span class='navfirstletter'>G</span>ithub</a>
      </li>
      <li class="nav-item">
        <a href="/tools" class="nav-link"><span class='navfirstletter'>T</span>ools</a>
      </li>
      <li class="nav-item">
        <a href="/docs/architecture" class="nav-link"><span class='navfirstletter'>D</span>ocs</a>
      </li>
      <li class="nav-item">
        <a href="/help" class="nav-link"><span class='navfirstletter'>H</span>elp</a>
      </li>
      <li class="nav-item">
        <a href="/blog" class="nav-link"><span class='navfirstletter'>B</span>log</a>
      </li>
      <!-- <li class="nav-item">
        <input type="text" name="search" />
      </li> -->
    </ul>
  </div>
</nav>

      </div>
    </div>





    <div class="jumbotron page-header">
      <div class="container">

        <div class="row hidden-sm-down">
          <div class="col-md-2">
            <div class="hyperlooplogo">
            </div>
          </div>
          <div class="col-md-8">

            <h1 class="display-4 project-name">Hyperloop</h1>

            <h4 class="display-7 project-tagline">

              The Complete Isomorphic Ruby Framework
            </h4>
          </div>

        </div>

        <div class="row hidden-md-up">
          <div class="col-md-3">
            <div class="hyperlooplogo">
            </div>
          </div>
          <div class="col-md-9">
            <h1 class="h1 project-name center-text">Hyperloop</h1>
            </br>
            <h2 class="h5 project-tagline center-text">
              The Complete Isomorphic Ruby Framework
            </h2>
          </div>

        </div>


      </div>
    </div>

    <div class="page-header-underline">
      <div class="container">

      </div>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-md-3 sidenavcol">
          
      <ul class="nav">
        <li class="nav-item"><a href="/docs/architecture">Hyperloop Architecture</a></li>
      </ul>

  <br>


    <ul class="nav">
      <li class="nav-item"><a href="/docs/components/docs">Hyperloop Components</a></li>
    </ul>


  <br>

    <ul class="nav">
      <li class="nav-item"><a href="/docs/stores/docs">Hyperloop Stores</a></li>
    </ul>


  <br>

    <ul class="nav">
      <li class="nav-item"><a href="/docs/router/docs">Hyperloop Router</a></li>
    </ul>

  <br>

    <ul class="navtoc">
<li class="navtoc-item">
<a href="#hyperloop-models">Hyperloop Models</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#isomorphic-models">Isomorphic Models</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#rails-5-1-x">Rails 5.1.x</a>
</li>
<li class="navtoc-item">
<a href="#explicit-scope-access">Explicit Scope Access</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#activerecord-api">ActiveRecord API</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#interfacing-to-react">Interfacing to React</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#rendering-cycle">Rendering Cycle</a>
</li>
<li class="navtoc-item">
<a href="#prerendering">Prerendering</a>
</li>
<li class="navtoc-item">
<a href="#lazy-loading">Lazy Loading</a>
</li>
<li class="navtoc-item">
<a href="#load-cycle-methods">Load Cycle Methods</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#class-methods">Class Methods</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#new-and-create">New and Create</a>
</li>
<li class="navtoc-item">
<a href="#scoping-and-finding">Scoping and Finding</a>
</li>
<li class="navtoc-item">
<a href="#relationships-and-aggregations">Relationships and Aggregations</a>
</li>
<li class="navtoc-item">
<a href="#defining-server-methods">Defining server methods</a>
</li>
<li class="navtoc-item">
<a href="#model-information">Model Information</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#instance-methods">Instance Methods</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#attribute-and-relationship-getter-and-setters">Attribute and Relationship Getter and Setters</a>
</li>
<li class="navtoc-item">
<a href="#saving">Saving</a>
</li>
<li class="navtoc-item">
<a href="#destroy">Destroy</a>
</li>
<li class="navtoc-item">
<a href="#other-instance-methods">Other Instance Methods</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#load-and-render-cycle">Load and Render Cycle</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#loading-and-loaded">loading? and loaded?</a>
</li>
<li class="navtoc-item">
<a href="#hyperloop-model-load-method">Hyperloop::Model.load method</a>
</li>
<li class="navtoc-item">
<a href="#force-loading-attributes">Force Loading Attributes</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#client-side-scoping">Client Side Scoping</a>
</li>
<li class="navtoc-item">
<a href="#activerecord-scope-enhancement">ActiveRecord Scope Enhancement</a>
<ul class="navtoc">
<li class="navtoc-item">
<ul class="navtoc">
<li class="navtoc-item">
<a href="#how-it-works">How it works</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#configuring-the-transport">Configuring the Transport</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#setting-up-simple-polling">Setting up Simple Polling</a>
</li>
<li class="navtoc-item">
<a href="#setting-up-action-cable">Setting up Action Cable</a>
</li>
<li class="navtoc-item">
<a href="#setting-up-pusher-com">Setting up Pusher.com</a>
</li>
<li class="navtoc-item">
<a href="#setting-up-pusher-fake">Setting up Pusher Fake</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#debugging">Debugging</a>
</li>
<li class="navtoc-item">
<a href="#common-errors">Common Errors</a>
</li>
</ul>
</li>
</ul>


  <br>

   <ul class="nav">
      <li class="nav-item"><a href="/docs/operations/docs">Hyperloop Operations</a></li>
  </ul>

  <br>


    <ul class="nav">
      <li class="nav-item"><strong><a href="/docs/policies/docs">Hyperloop Policies</a></strong></li>
    </ul>



  <div class="getstarted">
    <br>
    <hr>
    <p>NEWS: RubyHyperloop is to be renamed Hyperstack. Come and see the work-in-progress site: </p>
    <!-- <button type="button" class="btn btn-primary btn-lg btn-hyperlooppink" onclick="https://hyperstack.org';">https://hyperstack.org</button> -->
    <a href='https://hyperstack.org'>https://hyperstack.org</a>
  </div>

          <br>
        </div>
        <div class="col-md-9 main-content">
          <h1 id="hyperloop-models">Hyperloop Models</h1>

<p>Hyperloop <strong>Models</strong> are implemented in the <strong>HyperModel Gem</strong>.</p>

<p>In Hyperloop, your ActiveRecord Models are available in your Isomorphic code.</p>

<p>Components, Operations, and Stores have CRUD access to your server side ActiveRecord Models, using the standard ActiveRecord API.</p>

<p>In addition, Hyperloop implements push notifications (via a number of possible technologies) so changes to records on the server are dynamically pushed to all authorized clients.</p>

<p>In other words, one browser creates, updates, or destroys a Model, and the changes are persisted in ActiveRecord models and then broadcast to all other authorized clients.</p>

<ul>
<li>The <code>hyper-model</code> gem provides ActiveRecord Models to Hyperloop&#39;s Isomorphic architecture.</li>
<li>You access your Model data in your Components, Operations, and Stores just like you would on the server or in an ERB or HAML view file.</li>
<li>If an optional push transport is connected Hyperloop broadcasts any changes made to your ActiveRecord models as they are persisted on the server or updated by one of the authorized clients.</li>
<li>Some Models can be designated as <em>server-only</em> which means they are not available to the Isomorphic code.</li>
</ul>

<p>For example, consider a simple model called <code>Dictionary</code> which might be part of Wiktionary type app.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Dictionary</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>

  <span class="c1"># attributes</span>
  <span class="c1">#   word: string   </span>
  <span class="c1">#   definition: text</span>
  <span class="c1">#   pronunciation: string</span>

  <span class="n">scope</span> <span class="ss">:defined</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="s1">'definition IS NOT NULL AND pronunciation IS NOT NULL'</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>Here is a very simple Hyperloop Component that shows a random word from the dictionary:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">WordOfTheDay</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>

  <span class="k">def</span> <span class="nf">pick_entry!</span>  
    <span class="c1"># pick a random word and assign the selected record to entry</span>
    <span class="vi">@entry</span> <span class="o">=</span> <span class="no">Dictionary</span><span class="p">.</span><span class="nf">defined</span><span class="p">.</span><span class="nf">all</span><span class="p">[</span><span class="nb">rand</span><span class="p">(</span><span class="no">Dictionary</span><span class="p">.</span><span class="nf">defined</span><span class="p">.</span><span class="nf">count</span><span class="p">)]</span>
    <span class="n">force_update!</span> <span class="c1"># redraw our component when the word changes</span>
    <span class="c1"># Notice that we use standard ActiveRecord constructs to select our</span>
    <span class="c1"># random entry value</span>
  <span class="k">end</span>

  <span class="c1"># pick an initial entry before we mount our component...</span>
  <span class="n">before_mount</span> <span class="ss">:pick_entry</span>

  <span class="c1"># Again in our render block we use the standard ActiveRecord API, such</span>
  <span class="c1"># as the 'defined' scope, and the 'word', 'pronunciation', and</span>
  <span class="c1"># 'definition' attribute getters.  </span>
  <span class="n">render</span><span class="p">(</span><span class="no">DIV</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">DIV</span> <span class="p">{</span> <span class="s2">"total definitions: </span><span class="si">#{</span><span class="no">Dictionary</span><span class="p">.</span><span class="nf">defined</span><span class="p">.</span><span class="nf">count</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
    <span class="no">DIV</span> <span class="k">do</span>
      <span class="no">DIV</span> <span class="p">{</span> <span class="vi">@entry</span><span class="p">.</span><span class="nf">word</span> <span class="p">}</span>
      <span class="no">DIV</span> <span class="p">{</span> <span class="vi">@entry</span><span class="p">.</span><span class="nf">pronunciation</span> <span class="p">}</span>
      <span class="no">DIV</span> <span class="p">{</span> <span class="vi">@entry</span><span class="p">.</span><span class="nf">definition</span> <span class="p">}</span>
      <span class="no">BUTTON</span> <span class="p">{</span> <span class="s1">'pick another'</span> <span class="p">}.</span><span class="nf">on</span><span class="p">(</span><span class="ss">:click</span><span class="p">)</span> <span class="p">{</span> <span class="n">pick_entry!</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre>
<p>For complete examples with <em>push</em> updates, see any of the apps in the <code>examples</code> directory, or build your own in 5 minutes following one of the quickstart guides:</p>

<h2 id="isomorphic-models">Isomorphic Models</h2>

<p>Depending on the architecture of your application, you may decide that some of your models should be Isomorphic and some should remain server-only. The consideration will be that your Isomorphic models will be compiled by Opal to JavaScript and accessible on he client (without the need for a boilerplate API) - Hyperloop takes care of the communication between your server-side models and their client-side compiled versions and you can use Policy to govern access to the models.</p>

<p>In order for Hyperloop to see your Models (and his make them Isomorphic) you need to move them to the <code>hyperloop/models</code> folder. Only models in this folder will be seen by Hyperloop and compiled to Javascript. Once a Model is on this folder it ill be accessable to both your client and server code.</p>

<table><thead>
<tr>
<th><strong>Location of Models</strong></th>
<th><strong>Scope</strong></th>
</tr>
</thead><tbody>
<tr>
<td><code>app\models</code></td>
<td>Server-side code only</td>
</tr>
<tr>
<td><code>app\hyperloop\models</code></td>
<td>Isomorphic code (client and server)</td>
</tr>
</tbody></table>

<h3 id="rails-5-1-x">Rails 5.1.x</h3>

<p>Up until Rails 4.2, all models inherited from <code>ActiveRecord::Base</code>. But starting from Rails 5, all models will inherit from <code>ApplicationRecord</code>.</p>

<p>To accommodate this change, the following file has been automatically added to models in Rails 5 applications.</p>
<pre class="highlight ruby"><code><span class="c1"># app/models/application_record.rb</span>
<span class="k">class</span> <span class="nc">ApplicationRecord</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">abstract_class</span> <span class="o">=</span> <span class="kp">true</span>
<span class="k">end</span>
</code></pre>
<p>For Hyperloop to see this change, this file needs to be moved (or copied if you have some server-side models) to the <code>apps/hyperloop</code> folder.</p>

<h3 id="explicit-scope-access">Explicit Scope Access</h3>

<p>In order to prevent unauthorized access to information like scope counts, lists of record ids, etc, Hyperloop now (see issue <a href="https://github.com/ruby-hyperloop/hyper-mesh/issues/43">https://github.com/ruby-hyperloop/hyper-mesh/issues/43</a>) requires you explicitly allow scopes to be viewed on the client, otherwise you will get an AccessViolation.</p>

<p>To globally allow access to all scopes add this to the ApplicationRecord class</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">ApplicationRecord</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">regulate_scope</span> <span class="ss">:all</span>
<span class="k">end</span>
</code></pre>
<h2 id="activerecord-api">ActiveRecord API</h2>

<p>Hyperloop uses a subset of the standard ActiveRecord API to give your Isomorphic Components, Operations and Stores access to your server side Models.  As much as possible Hyperloop follows the syntax and semantics of ActiveRecord.  </p>

<h3 id="interfacing-to-react">Interfacing to React</h3>

<p>Hyperloop integrates with React (through Components) to deliver your Model data to the client without you having to create extra APIs or specialized controllers.  The key idea of React is that when state (or params) change, the portions of the display effected by this data will be updated.</p>

<p>Hyperloop automatically creates React state objects that will be updated as server side data is loaded or changes.  When these states change the associated parts of the display will be updated.</p>

<p>A brief overview of how this works will help you understand the how Hypeloop gets the job done.</p>

<h4 id="rendering-cycle">Rendering Cycle</h4>

<p>On the UI you will be reading models in order to display data.</p>

<p>If during the rendering of the display the Model data is not yet loaded, placeholder values (the default values from the <code>columns_hash</code>) will be returned by Hyperloop.  </p>

<p>Hyperloop then keeps track of where these placeholders (or <code>DummyValue</code>s) are displayed, and when they do get loaded, those parts of the display will re-render.</p>

<p>If later the data changes (either due to local user actions, or receiving push updates) then again any parts of the display that were dependent on the current values will be re-rendered.</p>

<p>You normally do not have to be aware of this.  Just access your Models using the normal scopes and finders, then compute values and display attributes as you would on the server.  Initially the display will show the placeholder values and then will be replaced with the real values.</p>

<h4 id="prerendering">Prerendering</h4>

<p>During server-side pre-rendering, Hyperloop has direct access to the server so on initial page load all the values will be loaded and present.  </p>

<h4 id="lazy-loading">Lazy Loading</h4>

<p>Hyperloop lazy loads values, and does not load any thing until an explicit displayable value is requested.  For example <code>Todo.all</code> will have no action, but <code>Todo.all.pluck[:title]</code> will return an array of titles.</p>

<p>At the end of the rendering cycle the set of all values requested will be merged into a tree structure and sent to the server, returning the minimum amount of data needed.</p>

<h4 id="load-cycle-methods">Load Cycle Methods</h4>

<p>There are a number of methods that allow you to interact with this load cycle when needed.  These are documented <a href="#other-methods-for-interacting-with-the-load-and-render-cycle">below</a>.</p>

<h3 id="class-methods">Class Methods</h3>

<h4 id="new-and-create">New and Create</h4>

<p><code>new</code>: Takes a hash of attributes and initializes a new unsaved record.  The values of any attributes not specified in the hash will be taken from the Models default values specified in the <code>columns_hash</code>.</p>

<p>If <code>new</code> is passed a native javascript object it will be treated as a hash and converted accordingly.</p>

<p><code>create</code>: Short hand for <code>new(...).save</code>.  See the <code>save</code> instance method for details on how saving is done.</p>

<h4 id="scoping-and-finding">Scoping and Finding</h4>

<p><code>scope</code> and <code>default_scope</code>:  Hyperloop adds four new options to these methods: <code>joins</code>, <code>client</code>, <code>select</code> and <code>server</code>.  The <code>joins</code> option provides information on how the scope will be joined with other models.  The <code>client</code> and <code>select</code> options allow scoping to be done on the client side to offload this from the server, and the <code>server</code> option is there just for symmetry with the other options.</p>
<pre class="highlight ruby"><code><span class="c1"># the active scope proc is executed on the server</span>
<span class="n">scope</span> <span class="ss">:active</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">completed: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>

<span class="c1"># if the scope does a join (or include) this must be indicated</span>
<span class="c1"># using the joins: option.</span>
<span class="n">scope</span> <span class="ss">:with_recent_comments</span><span class="p">,</span>
      <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">joins</span><span class="p">(</span><span class="ss">:comments</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s1">'comment.created_at &gt;= ?'</span><span class="p">,</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="nf">week</span><span class="p">)</span> <span class="p">},</span>
      <span class="ss">joins: </span><span class="p">[</span><span class="s1">'comments'</span><span class="p">]</span> <span class="c1"># or joins: 'comments'</span>

<span class="c1"># the server side proc can be indicated by the server: option</span>
<span class="c1"># an optional client side proc can be provided to compute the scope</span>
<span class="c1"># locally at the client</span>
<span class="n">scope</span> <span class="ss">:completed</span><span class="p">,</span>
      <span class="ss">server: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">complete: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
      <span class="ss">client: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">complete</span> <span class="p">}</span> <span class="c1"># return true if the record should be included</span>
</code></pre>
<p><code>unscoped</code> and <code>all</code>: These builtin scopes work just like standard ActiveRecord.</p>
<pre class="highlight ruby"><code><span class="no">Word</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">word</span><span class="o">|</span> <span class="no">LI</span> <span class="p">{</span> <span class="n">word</span><span class="p">.</span><span class="nf">text</span> <span class="p">}}</span>
</code></pre>
<p>BTW: to save typing you can skip the <code>all</code>:  Models will respond like enumerators.</p>

<p><code>find</code>: takes an id and delivers the corresponding record.</p>

<p><code>find_by</code>: takes a single item hash indicating an attribute value pair to find.</p>

<p><code>find_by_...</code>: i.e. <code>find_by_first_name</code> these methods will find the first record with a matching attribute.</p>
<pre class="highlight ruby"><code><span class="no">Word</span><span class="p">.</span><span class="nf">find_by_text</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">)</span> <span class="c1"># short for Word.find_by(text: 'hello')</span>
</code></pre>
<p><code>limit</code> and <code>offset</code>: These builtin scopes behave as they do on the server:</p>
<pre class="highlight ruby"><code><span class="no">Word</span><span class="p">.</span><span class="nf">offset</span><span class="p">(</span><span class="mi">500</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># get words 500-519</span>
</code></pre>
<h4 id="relationships-and-aggregations">Relationships and Aggregations</h4>

<p><code>belongs_to, has_many, has_one</code>:  These all work as on the server.  <strong>However it is important that you fully specify both sides of the relationship.</strong>  </p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Todo</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:assigned_to</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s1">'User'</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:todos</span><span class="p">,</span> <span class="ss">foreign_key: </span><span class="s1">'assigned_to_id'</span>
<span class="k">end</span>
</code></pre>
<p>Note that on the client the linkages between relationships are live and direct.  In the above example this works:</p>
<pre class="highlight ruby"><code><span class="no">Todo</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">assigned_to: </span><span class="n">some_user</span><span class="p">)</span>
</code></pre>
<p>but this may not:</p>
<pre class="highlight ruby"><code><span class="no">Todo</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">assigned_to_id: </span><span class="n">some_user</span><span class="p">.</span><span class="nf">id</span><span class="p">)</span>
</code></pre>
<p><code>composed_of</code>: You can create aggregate models like ActiveRecord.</p>

<p>Similar to the linkages in relationships, aggregate records are represented on the client as actual independent objects.</p>

<h4 id="defining-server-methods">Defining server methods</h4>

<p>Normally an application defined instance method will run on the client and the server:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">def</span> <span class="nf">full_name</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">first_name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">last_name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Sometimes it is desirable to only run the method on the server.  This can be done using the <code>server_method</code> macro:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">server_method</span> <span class="ss">:full_name</span><span class="p">,</span> <span class="ss">default: </span><span class="s1">''</span> <span class="k">do</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">first_name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">last_name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>When the method is first called on the client the default value will be returned, and there will be a reactive update when the true value is returned from the server.</p>

<p>To force the value to be recomputed at the server append a  <code>!</code> to the end of the name, otherwise the last value returned from the server will continue to be returned.</p>

<h4 id="model-information">Model Information</h4>

<p><code>column_names</code>: returns a list of the database columns.</p>

<p><code>columns_hash</code>: returns the details of the columns specification.  Note that on the server <code>columns_hash</code> returns a hash of objects specifying column information.  On the client the entire structure is just one big hash of hashes.</p>

<p><code>abstract_class=</code>, <code>abstract_class?</code>, <code>primary_key</code>, <code>primary_key=</code>, <code>inheritance_column</code>, <code>inheritance_column=</code>, <code>model_name</code>:  All work as on the server.  See ActiveRecord documentation for more info.</p>

<h3 id="instance-methods">Instance Methods</h3>

<h4 id="attribute-and-relationship-getter-and-setters">Attribute and Relationship Getter and Setters</h4>

<p>All attributes have an associated getter and setter. All relationships have a getter.  All <code>belongs_to</code> relationships also have a setter.  <code>has_many</code> relationships can be updated using the push (<code>&lt;&lt;</code>) operator or using the <code>delete</code> method.</p>
<pre class="highlight ruby"><code>  <span class="nb">puts</span> <span class="n">my_todo</span><span class="p">.</span><span class="nf">title</span>
  <span class="n">my_todo</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"neutitle"</span>
  <span class="n">my_todo</span><span class="p">.</span><span class="nf">comments</span> <span class="o">&lt;&lt;</span> <span class="n">a_new_comment</span>
  <span class="n">a_new_comment</span><span class="p">.</span><span class="nf">todo</span> <span class="o">==</span> <span class="n">my_todo</span> <span class="c1"># true!</span>
</code></pre>
<p>In addition if the attribute getter ends with a bang (!) then this will force a fetch of the attribute from the server.  This is typically not necessary if push updates are configured.</p>

<h4 id="saving">Saving</h4>

<p>The <code>save</code> method works like ActiveRecord save, <em>except</em> it returns a promise that is resolved when the save completes (or fails.)</p>
<pre class="highlight ruby"><code><span class="n">my_todo</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="ss">validate: </span><span class="kp">false</span><span class="p">).</span><span class="nf">then</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="o">|</span>
  <span class="c1"># result is a hash with {success: ..., message: , models: ....}</span>
<span class="k">end</span>
</code></pre>
<p>After a save operation completes the models will have an <code>errors</code> hash (just like on the server) with any validation problems.</p>

<p>During the save operation the method <code>saving?</code> will return <code>true</code>.  This can be used to instead of (or with) the promise to update the screen:</p>
<pre class="highlight ruby"><code><span class="n">render</span> <span class="k">do</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">if</span> <span class="n">some_model</span><span class="p">.</span><span class="nf">saving?</span>
    <span class="p">.</span><span class="nf">.</span><span class="p">.</span> <span class="nf">display</span> <span class="n">please</span> <span class="n">wait</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">elsif</span> <span class="n">some_model</span><span class="p">.</span><span class="nf">errors</span><span class="p">.</span><span class="nf">any?</span>
    <span class="p">.</span><span class="nf">.</span><span class="p">.</span> <span class="nf">highlight</span> <span class="n">the</span> <span class="n">errors</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">else</span>
    <span class="p">.</span><span class="nf">.</span><span class="p">.</span> <span class="nf">display</span> <span class="n">data</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">end</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<h4 id="destroy">Destroy</h4>

<p>Like <code>save</code> destroy returns a promise that is resolved when the destroy completes.</p>

<p>After the destroy completes the record&#39;s <code>destroyed?</code> method will return true.</p>

<h4 id="other-instance-methods">Other Instance Methods</h4>

<p><code>new?</code> returns true if the model is new and not yet saved.</p>

<p><code>primary_key</code> returns the primary key for the model</p>

<p><code>id</code> returns the value of the primary key for this instance</p>

<p><code>model_name</code> returns the model_name.</p>

<p><code>revert</code> Undoes any unsaved changes to the instance.</p>

<p><code>changed?</code> returns true if any attributes have changed (always true for a new model)</p>

<p><code>dup</code> duplicate the instance.</p>

<p><code>==</code> two instances are the same if it is known that they reference the same underlying table row.  </p>

<p><code>..._changed?</code> (i.e. name_changed?) returns true if the specific attribute has changed.</p>

<p><code>itself</code> returns the record, but will override lazy loading and force a load of at least the model&#39;s id.</p>

<h3 id="load-and-render-cycle">Load and Render Cycle</h3>

<h4 id="loading-and-loaded">loading? and loaded?</h4>

<p>All Ruby objects will respond to these methods.  If you want to put up a &quot;Please Wait&quot; message, spinner, etc, you can use the <code>loaded?</code> or <code>loading?</code> method to determine if the object represents a real loaded value or not.  Any value for which <code>loaded?</code> returns <code>false</code> (or <code>loading?</code> returns <code>true</code>) will eventually load and cause a re-render</p>

<h4 id="hyperloop-model-load-method">Hyperloop::Model.load method</h4>

<p>Sometimes it is necessary to insure values are loaded outside of the rendering cycle.  For this you can use the <code>Hyperloop::Model.load</code> method:</p>
<pre class="highlight ruby"><code><span class="no">Hyperloop</span><span class="o">::</span><span class="no">Model</span><span class="p">.</span><span class="nf">load</span> <span class="k">do</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">my_model</span><span class="p">.</span><span class="nf">some_attribute</span>
  <span class="no">OtherModel</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">12</span><span class="p">).</span><span class="nf">other_attribute</span>
  <span class="c1"># code in here can be arbitrarily complex and load</span>
  <span class="c1"># will re-execute it until all values are loaded</span>
  <span class="c1"># the final expression is passed to the promise</span>
<span class="k">end</span><span class="p">.</span><span class="nf">then</span> <span class="o">|</span><span class="n">result</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">result</span>
<span class="k">end</span>
</code></pre>
<h4 id="force-loading-attributes">Force Loading Attributes</h4>

<p>Normally you will simply display attributes as part of the render method, and when the values are loaded from the server the component will re-render.</p>

<p>Sometimes outside of the render method you may need to insure an attribute (or a server side method) is loaded before proceeding.  This is typically when you are building some kind of higher level store.  </p>

<p>The <code>load</code> method takes a list of attributes (symbols) and will insure these are loaded.  Load returns a promise that is resolved when the load completes, or can be passed a block that will execute when the load completes.</p>
<pre class="highlight ruby"><code><span class="n">before_mount</span> <span class="k">do</span>
  <span class="no">Todo</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="ss">:name</span><span class="p">).</span><span class="nf">then</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span><span class="p">;</span>
    <span class="n">state</span><span class="p">.</span><span class="nf">loaded!</span> <span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Think hard about how you are using this, as Hyperloop already acts as flux store, and is managing state for you.  It may be you are just creating a redundant store!</p>

<h2 id="client-side-scoping">Client Side Scoping</h2>

<p>By default scopes will be recalculated on the server.  For simple scopes that do not use joins or includes no additional action needs to be taken to make scopes work with Hyperloop.  For scopes that do use joins, or if you want to offload the scoping computation from the server to the client read this section.</p>

<h2 id="activerecord-scope-enhancement">ActiveRecord Scope Enhancement</h2>

<p>When the client receives notification that a record has changed Hyperloop finds the set of currently rendered scopes that might be effected, and requests them to be updated from the server.  </p>

<p>On the server scopes are a useful way to structure code.  <strong>On the client</strong> scopes are vital as they limit the amount of data loaded, viewed, and updated in the browser.  Consider a factory floor management system that shows <em>job</em> state as work flows through the factory.  There may be millions of jobs that a production floor browser is authorized to view, but at any time there are probably only 50 being shown.  Using ActiveRecord scopes is the way Hyperloop keeps the data requested by the browser limited to a reasonable amount.  </p>

<p>To make scopes work efficiently on the client Hyperloop adds some features to the ActiveRecord <code>scope</code> and <code>default_scope</code> macros.  Note you must use the <code>scope</code> macro (and not class methods) for things to work with Hyperloop.</p>

<p>The additional features are accessed via the <code>:joins</code>, <code>:client</code>, and <code>:select</code> options.</p>

<p>The <code>:joins</code> option tells the Hyperloop client which models are joined with the scope.  <em>You must add a <code>:joins</code> option if the scope has any data base join operations in it, otherwise if a joined model changes, Hyperloop will not know to update the scope.</em></p>

<p>The <code>:client</code> and <code>:select</code> options provide the client a way to update scopes without having to contact the server.  Unlike the <code>:joins</code> option this is an optimization and is not required for scopes to work.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Todo</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>

  <span class="c1"># Standard ActiveRecord form:</span>
  <span class="c1"># the proc will be evaluated as normal on the server, and as needed updates</span>
  <span class="c1"># will be requested from the clients</span>

  <span class="n">scope</span> <span class="ss">:active</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">completed: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>

  <span class="c1"># In the simple form the scope will be reevaluated if the model that is</span>
  <span class="c1"># being scoped changes, and if the scope is currently being used to render data.</span>

  <span class="c1"># If the scope joins with other data you will need to specify this by</span>
  <span class="c1"># passing a relationship or array of relationships to the `joins` option.</span>

  <span class="n">scope</span> <span class="ss">:with_recent_comments</span><span class="p">,</span>
        <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">joins</span><span class="p">(</span><span class="ss">:comments</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s1">'comment.created_at &gt;= ?'</span><span class="p">,</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="nf">week</span><span class="p">)</span> <span class="p">},</span>
        <span class="ss">joins: </span><span class="p">[</span><span class="s1">'comments'</span><span class="p">]</span> <span class="c1"># or joins: 'comments'</span>

  <span class="c1"># Now with_recent_comments will be re-evaluated whenever a Todo record, or a Comment</span>
  <span class="c1"># joined with a Todo change.</span>

  <span class="c1"># Normally whenever Hyperloop detects that a scope may be effected by a changed</span>
  <span class="c1"># model, it will request the scope be re-evaluated on the server.  To offload this</span>
  <span class="c1"># computation to the client provide a client side scope method:</span>

  <span class="n">scope</span> <span class="ss">:with_recent_comments</span><span class="p">,</span>
        <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">joins</span><span class="p">(</span><span class="ss">:comments</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s1">'comment.created_at &gt;= ?'</span><span class="p">,</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="nf">week</span><span class="p">)</span> <span class="p">},</span>
        <span class="ss">joins: </span><span class="p">[</span><span class="s1">'comments'</span><span class="p">]</span>
        <span class="ss">client: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">comments</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">comment</span><span class="o">|</span> <span class="n">comment</span><span class="p">.</span><span class="nf">created_at</span> <span class="o">&gt;=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="nf">week</span> <span class="p">}</span>

  <span class="c1"># The client proc is executed on each candidate record, and if it returns true the record</span>
  <span class="c1"># will be added to the scope.</span>

  <span class="c1"># Instead of a client proc you can provide a select proc, which will receive the entire</span>
  <span class="c1"># collection which can then be filtered and sorted.</span>

  <span class="n">scope</span> <span class="ss">:sort_by_created_at</span><span class="p">,</span>
        <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span><span class="p">(</span><span class="s1">'created_at DESC'</span><span class="p">)</span> <span class="p">}</span>
        <span class="ss">select: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">b</span><span class="p">.</span><span class="nf">created_at</span> <span class="o">&lt;=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">created_at</span> <span class="p">}}</span>

  <span class="c1"># To keep things tidy you can specify the server scope proc with the :server option</span>

  <span class="n">scope</span> <span class="ss">:completed</span><span class="p">,</span>
        <span class="ss">server: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">complete: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
        <span class="ss">client: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">complete</span> <span class="p">}</span>

  <span class="c1"># The expressions in the joins array can be arbitrary sequences of relationships and</span>
  <span class="c1"># scopes such as 'comments.author'.  </span>

  <span class="n">scope</span> <span class="ss">:with_managers_comments</span><span class="p">,</span>
        <span class="ss">server: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>
        <span class="ss">joins: </span><span class="p">[</span><span class="s1">'comments.author'</span><span class="p">,</span> <span class="s1">'owner'</span><span class="p">]</span>
        <span class="ss">client: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">comments</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">comment</span><span class="o">|</span> <span class="n">comment</span><span class="p">.</span><span class="nf">author</span> <span class="o">==</span> <span class="n">owner</span><span class="p">.</span><span class="nf">manager</span> <span class="p">}}}</span>

  <span class="c1"># You can also use the client, select, server, and joins option with the default_scope macro</span>

  <span class="n">default_scope</span> <span class="ss">server: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">deleted: </span><span class="kp">false</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s1">'updated_at DESC'</span><span class="p">)</span> <span class="p">}</span>
                <span class="ss">select: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">r</span><span class="o">|</span> <span class="o">!</span><span class="n">r</span><span class="p">.</span><span class="nf">deleted</span> <span class="p">}.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">b</span> <span class="o">&lt;=&gt;</span> <span class="n">a</span> <span class="p">}</span> <span class="p">}</span>

  <span class="c1"># NOTE: it is highly recommend to provide a client proc with default_scopes.  Otherwise</span>
  <span class="c1"># every change is going to require a server interaction regardless of what other client procs</span>
  <span class="c1"># you provide.</span>

<span class="k">end</span>
</code></pre>
<h4 id="how-it-works">How it works</h4>

<p>Consider this scope on the Todo model</p>
<pre class="highlight ruby"><code><span class="n">scope</span> <span class="ss">:with_managers_comments</span><span class="p">,</span>
      <span class="ss">server: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">joins</span><span class="p">(</span><span class="ss">owner: :manager</span><span class="p">,</span> <span class="ss">comments: :author</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s1">'managers_users.id = authors_comments.id'</span><span class="p">).</span><span class="nf">distinct</span> <span class="p">},</span>
      <span class="ss">client: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">comments</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">comment</span><span class="o">|</span> <span class="n">comment</span><span class="p">.</span><span class="nf">author</span> <span class="o">==</span> <span class="n">owner</span><span class="p">.</span><span class="nf">manager</span> <span class="p">}}</span>
      <span class="ss">joins: </span><span class="p">[</span><span class="s1">'comments.author'</span><span class="p">,</span> <span class="s1">'owner'</span><span class="p">]</span>
</code></pre>
<p>The joins &#39;comments.author&#39; relationship is inverted so that we have User &#39;has<em>many&#39; Comments which &#39;belongs</em>to&#39; Todos.</p>

<p>Thus we now know that whenever a User or a Comment changes this may effect our with<em>managers</em>comments scope</p>

<p>Likewise &#39;owner&#39; becomes User &#39;has_many&#39; Todos.</p>

<p>Lets say that a user changes teams and now has a new manager.  This means according to the relationships that the
User model will change (i.e. there will be a new manager_id in the User model) and thus all Todos belonging to that
User are subject to evaluation.</p>

<p>While the server side proc efficiently delivers all the objects in the scope, the client side proc just needs to incrementally update the scope.</p>

<h2 id="configuring-the-transport">Configuring the Transport</h2>

<p>Hyperloop implements push notifications (via a number of possible technologies) so changes to records on the server are dynamically pushed to all authorized clients.</p>

<p>The can be accomplished by configuring <strong>one</strong> of the push technologies below:</p>

<table><thead>
<tr>
<th>Push Technology</th>
<th>When to choose this...</th>
</tr>
</thead><tbody>
<tr>
<td><a href="#setting-up-simple-polling">Simple Polling</a></td>
<td>The easiest push transport is the built-in simple poller.  This is great for demos or trying out Hyperloop but because it is constantly polling it is not suitable for production systems or any kind of real debug or test activities.</td>
</tr>
<tr>
<td><a href="#setting-up-action-cable">Action Cable</a></td>
<td>If you are using Rails 5 this is the perfect route to go. Action Cable is a production ready transport built into Rails 5.</td>
</tr>
<tr>
<td><a href="#setting-up-pusher-com">Pusher.com</a></td>
<td>Pusher.com is a commercial push notification service with a free basic offering. The technology works well but does require a connection to the internet at all times.</td>
</tr>
<tr>
<td><a href="#setting-up-pusher-fake">Pusher Fake</a></td>
<td>The Pusher-Fake gem will provide a transport using the same protocol as pusher.com but you can use it to locally test an app that will be put into production using pusher.com.</td>
</tr>
</tbody></table>

<h3 id="setting-up-simple-polling">Setting up Simple Polling</h3>

<p>The easiest push transport is the built-in simple poller.  This is great for demos or trying out Hyperloop but because it is constantly polling it is not suitable for production systems or any kind of real debug or test activities.</p>

<p>Simply add this initializer:</p>
<pre class="highlight ruby"><code><span class="c1">#config/initializers/hyperloop.rb</span>
<span class="no">Hyperloop</span><span class="p">.</span><span class="nf">configuration</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">transport</span> <span class="o">=</span> <span class="ss">:simple_poller</span>
  <span class="c1"># options</span>
  <span class="c1"># config.opts = {</span>
  <span class="c1">#   seconds_between_poll: 5, # default is 0.5 you may need to increase if testing with Selenium</span>
  <span class="c1">#   seconds_polled_data_will_be_retained: 1.hour  # clears channel data after this time, default is 5 minutes</span>
  <span class="c1"># }</span>
<span class="k">end</span>
</code></pre>
<p>That&#39;s it. Hyperloop will use simple polling for the push transport.</p>

<hr>

<h3 id="setting-up-action-cable">Setting up Action Cable</h3>

<p>To configure Hyperloop to use Action Cable, add this initializer:</p>
<pre class="highlight ruby"><code><span class="c1">#config/initializers/hyperloop.rb</span>
<span class="no">Hyperloop</span><span class="p">.</span><span class="nf">configuration</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">transport</span> <span class="o">=</span> <span class="ss">:action_cable</span>
<span class="k">end</span>
</code></pre>
<p>If you are already using ActionCable in your app that is fine, as Hyperloop will not interfere with your existing connections.</p>

<p><strong>Otherwise</strong> go through the following steps to setup ActionCable.</p>

<p>Firstly, make sure the <code>action_cable</code> js file is required in your assets.</p>

<p>Typically <code>app/assets/javascripts/application.js</code> will finish with a <code>require_tree .</code> and this will pull in the <code>cable.js</code> file which will pull in <code>action_cable.js</code></p>

<p>However at a minimum if <code>application.js</code> simply does a <code>require action_cable</code> that will be sufficient for Hyperloop.</p>

<p>Make sure you have a cable.yml file:</p>
<pre class="highlight yaml"><code><span class="c1"># config/cable.yml</span>
<span class="na">development</span><span class="pi">:</span>
  <span class="na">adapter</span><span class="pi">:</span> <span class="s">async</span>

<span class="na">test</span><span class="pi">:</span>
  <span class="na">adapter</span><span class="pi">:</span> <span class="s">async</span>

<span class="na">production</span><span class="pi">:</span>
  <span class="na">adapter</span><span class="pi">:</span> <span class="s">redis</span>
  <span class="na">url</span><span class="pi">:</span> <span class="s">redis://localhost:6379/1</span>
</code></pre>
<p>Set allowed request origins (optional):</p>

<p><strong>By default action cable will only allow connections from localhost:3000 in development.</strong>  If you are going to something other than localhost:3000 you need to add something like this to your config:</p>
<pre class="highlight ruby"><code><span class="c1"># config/environments/development.rb</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">configure</span> <span class="k">do</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">action_cable</span><span class="p">.</span><span class="nf">allowed_request_origins</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'http://localhost:3000'</span><span class="p">,</span> <span class="s1">'http://localhost:5000'</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
<p>That&#39;s it. Hyperloop will use Action Cable as the push transport.</p>

<hr>

<h3 id="setting-up-pusher-com">Setting up Pusher.com</h3>

<p><a href="https://pusher.com/">Pusher.com</a> provides a production ready push transport for your App.  You can combine this with <a href="/docs/pusher_faker_quickstart.md">Pusher-Fake</a> for local testing as well.  You can get a free pusher account and API keys at <a href="https://pusher.com">https://pusher.com</a></p>

<p>First add the Pusher and HyperLoop gems to your Rails app:</p>

<p>add <code>gem &#39;pusher&#39;</code> to your Gemfile.</p>

<p>Next Add the pusher js file to your application.js file:</p>
<pre class="highlight ruby"><code><span class="c1"># app/assets/javascript/application.js</span>
<span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">/</span><span class="o">/=</span> <span class="nb">require</span> <span class="s1">'hyperloop/pusher'</span>
<span class="sr">//</span><span class="o">=</span> <span class="n">require_tree</span> <span class="o">.</span>
</code></pre>
<p>Finally set the transport:</p>
<pre class="highlight ruby"><code><span class="c1"># config/initializers/Hyperloop.rb</span>
<span class="no">Hyperloop</span><span class="p">.</span><span class="nf">configuration</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">transport</span> <span class="o">=</span> <span class="ss">:pusher</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">channel_prefix</span> <span class="o">=</span> <span class="s2">"Hyperloop"</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">opts</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">app_id: </span><span class="s2">"2....9"</span><span class="p">,</span>
    <span class="ss">key: </span><span class="s2">"f.....g"</span><span class="p">,</span>
    <span class="ss">secret: </span><span class="s2">"1.......3"</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>That&#39;s it. You should be all set for push notifications using Pusher.com.</p>

<hr>

<h3 id="setting-up-pusher-fake">Setting up Pusher Fake</h3>

<p>The <a href="https://github.com/tristandunn/pusher-fake">Pusher-Fake</a> gem will provide a transport using the same protocol as pusher.com.  You can use it to locally test an app that will be put into production using pusher.com.</p>

<p>Firstly add the Pusher, Pusher-Fake and HyperLoop gems to your Rails app</p>

<ul>
<li>add <code>gem &#39;pusher&#39;</code> to your Gemfile.</li>
<li>add <code>gem &#39;pusher-fake&#39;</code> to the development and test sections of your Gemfile.</li>
</ul>

<p>Next add the pusher js file to your application.js file</p>
<pre class="highlight ruby"><code><span class="c1"># app/assets/javascript/application.js</span>
<span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">/</span><span class="o">/=</span> <span class="nb">require</span> <span class="s1">'hyperloop/pusher'</span>
<span class="sr">//</span><span class="o">=</span> <span class="n">require_tree</span> <span class="o">.</span>
</code></pre>
<p>Add this initializer to set the transport:</p>
<pre class="highlight ruby"><code><span class="c1"># typically app/config/initializers/Hyperloop.rb</span>
<span class="c1"># or you can do a similar setup in your tests (see this gem's specs)</span>
<span class="nb">require</span> <span class="s1">'pusher'</span>
<span class="nb">require</span> <span class="s1">'pusher-fake'</span>
<span class="c1"># Assign any values to the Pusher app_id, key, and secret config values.</span>
<span class="c1"># These can be fake values or the real values for your pusher account.</span>
<span class="no">Pusher</span><span class="p">.</span><span class="nf">app_id</span> <span class="o">=</span> <span class="s2">"MY_TEST_ID"</span>      <span class="c1"># you use the real or fake values</span>
<span class="no">Pusher</span><span class="p">.</span><span class="nf">key</span> <span class="o">=</span>    <span class="s2">"MY_TEST_KEY"</span>
<span class="no">Pusher</span><span class="p">.</span><span class="nf">secret</span> <span class="o">=</span> <span class="s2">"MY_TEST_SECRET"</span>
<span class="c1"># The next line actually starts the pusher-fake server (see the Pusher-Fake readme for details.)</span>
<span class="nb">require</span> <span class="s1">'pusher-fake/support/base'</span> <span class="c1"># if using pusher with rspec change this to pusher-fake/support/rspec</span>
<span class="c1"># now copy over the credentials, and merge with PusherFake's config details</span>
<span class="no">Hyperloop</span><span class="p">.</span><span class="nf">configuration</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">transport</span> <span class="o">=</span> <span class="ss">:pusher</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">channel_prefix</span> <span class="o">=</span> <span class="s2">"Hyperloop"</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">opts</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">app_id: </span><span class="no">Pusher</span><span class="p">.</span><span class="nf">app_id</span><span class="p">,</span>
    <span class="ss">key: </span><span class="no">Pusher</span><span class="p">.</span><span class="nf">key</span><span class="p">,</span>
    <span class="ss">secret: </span><span class="no">Pusher</span><span class="p">.</span><span class="nf">secret</span>
  <span class="p">}.</span><span class="nf">merge</span><span class="p">(</span><span class="no">PusherFake</span><span class="p">.</span><span class="nf">configuration</span><span class="p">.</span><span class="nf">web_options</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<p>That&#39;s it. You should be all set for push notifications using Pusher Fake.</p>

<h2 id="debugging">Debugging</h2>

<p>Sometimes you need to figure out what connections are available, or what attributes are readable etc.</p>

<p>Its usually all to do with your policies, but perhaps you just need a little investigation.</p>

<p>TODO check rr has become hyperloop (as below)</p>

<p>You can bring up a console within the controller context by browsing <code>localhost:3000/hyperloop/console</code></p>

<p><strong>Note:  change <code>rr</code> to wherever you are mounting Hyperloop in your routes file.</strong></p>

<p><strong>Note: in rails 4, you will need to add the gem &#39;web-console&#39; to your development section</strong></p>

<p>Within the context you have access to <code>session.id</code> and current <code>acting_user</code> which you will need, plus some helper methods to reduce typing</p>

<ul>
<li><p>Getting auto connection channels:<br>
<code>channels(session_id = session.id, user = acting_user)</code><br>
e.g. <code>channels</code> returns all channels connecting to this session and user providing nil as the acting_user will test if connections can be made without there being a logged in user.</p></li>
<li><p>Can a specific class connection be made:
<code>can_connect?(channel, user = acting_user)</code>
e.g. <code>can_connect? Todo</code>  returns true if current acting_user can connect to the Todo class. You can also provide the class name as a string.</p></li>
<li><p>Can a specific instance connection be made:
<code>can_connect?(channel, user = acting_user)</code>
e.g. <code>can_connect? Todo.first</code>  returns true if current acting_user can connect to the first Todo Model. You can also provide the instance in the form &#39;Todo-123&#39;</p></li>
<li><p>What attributes are accessible for a Model instance:<br>
<code>viewable_attributes(instance, user = acting_user)</code></p></li>
<li><p>Can the attribute be viewed:<br>
<code>view_permitted?(instance, attribute, user = acting_user)</code></p></li>
<li><p>Can a Model be created/updated/destroyed:
<code>create_permitted?(instance, user = acting_user)</code><br>
e.g. <code>create_permitted?(Todo.new, nil)</code> can anybody save a new todo?<br>
e.g. <code>destroy_permitted?(Todo.last)</code> can the acting_user destroy the last Todo</p></li>
</ul>

<p>You can of course simulate server side changes to your Models through this console like any other console.  For example</p>

<p><code>Todo.new.save</code> will broadcast the changes to the Todo Model to any authorized channels.</p>

<h2 id="common-errors">Common Errors</h2>

<ul>
<li><p><strong>No policy class</strong>
If you don&#39;t define a policy file, nothing will happen because nothing will get connected. By default Hyperloop will look for a <code>ApplicationPolicy</code> class.</p></li>
<li><p><strong>Wrong version of pusher-fake</strong>  (pusher-fake/base vs. pusher-fake/rspec) See the Pusher-Fake gem repo for details.</p></li>
<li><p>Forgetting to add <code>require pusher</code> in application.js file
this results in an error like this:
<code>text
Exception raised while rendering #&lt;TopLevelRailsComponent:0x53e&gt;
  ReferenceError: Pusher is not defined
</code>
To resolve make sure you <code>require &#39;pusher&#39;</code> in your application.js file if using pusher.  DO NOT require pusher from your components manifest as this will cause prerendering to fail.</p></li>
<li><p><strong>No create/update/destroy policies</strong>
You must explicitly allow changes to the Models to be made by the client. If you don&#39;t you will see 500 responses from the server when you try to update. To open all access do this in your application policy: <code>allow_change(to: :all, on: [:create, :update, :destroy]) { true }</code></p></li>
<li><p><strong>Cannot connect to real pusher account</strong>
If you are trying to use a real pusher account (not pusher-fake) but see errors like this
<code>text
pusher.self.js?body=1:62 WebSocket connection to
&#39;wss://127.0.0.1/app/PUSHER_API_KEY?protocol=7&amp;client=js&amp;version=3.0.0&amp;flash=false&#39;
failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED
</code>
Check to see if you are including the pusher-fake gem.
Hyperloop will always try to use pusher-fake if it sees the gem included.  Remove it and you should be good to go.  See <a href="https://github.com/hyper-react/HyperMesh/issues/5">issue #5</a> for more details.</p></li>
<li><p><strong>Cannot connect with ActionCable.</strong>
Make sure that <code>config.action_cable.allowed_request_origins</code> includes the url you use for development (including the port) and that you are using <code>Puma</code>.</p></li>
<li><p><strong>Attributes are not being converted from strings, or do not have their default values</strong>
Eager loading is probably turned off.  Hyperloop needs to eager load <code>hyperloop/models</code> so it can find all the column information for all Isomorphic models.</p></li>
<li><p><strong>When starting rails you get a message on the rails console <code>couldn&#39;t find file &#39;browser&#39;</code></strong>
The <code>hyper-component</code> v0.10.0 gem removed the dependency on opal-browser.  You will have to add the &#39;opal-browser&#39; gem to your Gemfile.</p></li>
<li><p><strong>On page load you get a message about super class mismatch for <code>DummyValue</code></strong>
You are still have the old <code>reactive-record</code> gem in your Gemfile, remove it from your gemfile and your components manifest.</p></li>
<li><p><strong>On page load you get a message about no method <code>session</code> for <code>nil</code></strong>
You are still referencing the old reactive-ruby or reactrb gems either directly or indirectly though a gem like reactrb-router.  Replace any gems like <code>reactrb-router</code> with <code>hyper-router</code>.  You can also just remove <code>reactrb</code>, as <code>hyper-model</code> will be included by the <code>hyper-model</code> gem.</p></li>
<li><p><strong>You keep seeing the message <code>WebSocket connection to &#39;ws://localhost:3000/cable&#39; failed: WebSocket is closed before the connection is established.</code></strong> every few seconds in the console.
There are probably lots of reasons for this, but it means ActionCable can&#39;t get itself going.  One reason is that you are trying to run with Passenger instead of Puma, and trying to use <code>async</code> mode in cable.yml file.  <code>async</code> mode requires Puma.</p></li>
</ul>

        </div>
      </div>
    </div>

    <div class="page-footer-upperline">
      <div class="container">

      </div>
    </div>

    <footer class="nav-footer">
  <section class="sitemap">

    <a href="/" class="nav-home"></a>

    <div>
      <h6><a href="/start/components" class="hyperloop-white">Start</a></h6>
      <a href="/start/components">Components</a>
      <a href="/start/stores">Stores</a>
      <a href="/start/models">Models</a>
      <a href="/start/operations">Operations</a>
      <a href="/start/policies">Policies</a>
      <a href="/start/pragmatic">Pragmatic Thinking</a>
    </div>
    <div>


      <h6><a href="/tutorials" class="hyperloop-white">Tutorials</a></h6>
      <a href="/tutorials/hyperloopcomps">Hyperloop COMPS</a>
      <a href="/tutorials/hyperloopjs">Hyperloop.js</a>
      <a href="/tutorials/hyperlooprails">Hyperloop and Rails</a>
      <a href="/tutorials/hyperloopdeploy">Hyperloop deployment</a>
      <a href="/tutorials/opal">Opal</a>
      <a href="/tutorials/videos">Videos</a>
    </div>
    <div>
      <h6><a href="/installation" class="hyperloop-white">Installation</a></h6>
      <a href="/installation#opal-playground">Hyperloop.js</a>
  	  <a href="/installation#ror">With Ruby On Rails</a>
  	  <a href="/installation#with-sinatra">With Sinatra</a>
  	  <a href="/installation#deployment">Deployment</a>
    </div>
    <div>
      <h6><a href="/gems" class="hyperloop-white">Gems</a></h6>
      <a href="https://github.com/ruby-hyperloop/hyperloop">hyperloop</a>
      <a href="https://github.com/ruby-hyperloop/hyperloop-js">hyperloop-js</a>
      <a href="https://github.com/ruby-hyperloop/hyper-react">hyper-component</a>
      <a href="https://github.com/ruby-hyperloop/hyper-store">hyper-store</a>
      <a href="https://github.com/ruby-hyperloop/hyper-mesh">hyper-model</a>
      <a href="https://github.com/ruby-hyperloop/hyper-operation">hyper-operation</a>
      <a href="https://github.com/ruby-hyperloop/reactrb-router/tree/v2-4-0">hyper-router</a>
      <a href="https://github.com/ruby-hyperloop/hyper-spec">hyper-spec</a>
      <a href="https://github.com/ruby-hyperloop/hyper-trace">hyper-trace</a>
    </div>
    <div>
      <h6><a href="/tools" class="hyperloop-white">Tools</a></h6>
      <a href="#testing">Testing</a>
    	<a href="#tools">Tools</a>
    	<a href="#debugging">Debugging</a>
    </div>
    <div>
      <h6><a href="/docs/architecture" class="hyperloop-white">Docs</a></h6>
      <a href="/docs/architecture">Architecture</a>
      <a href="/docs/components/docs#components-dsl-overview">Components</a>
      <a href="/docs/stores/docs">Stores</a>
      <a href="/docs/models/docs">Models</a>
      <a href="/docs/operations/docs">Operations</a>
      <a href="/docs/policies/docs">Policies</a>
    </div>

  </section>

  <section class="otherlinks">
    <a href="https://github.com/ruby-hyperloop" class="hyperloop-white">Github</a>
    <a href="/support" class="hyperloop-white">Help</a>
    <a href="/blog" class="hyperloop-white">Blog</a>
  </section>

  <section class="copyright">
    Copyright © 2018 Hyperloop.
  </section>
</footer>


    <script>
      (function(Opal) {
        var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;
        Opal.add_stubs(['$puts']);
        return self.$puts("Opal ok")
      })(Opal);
    </script>

    <!-- <script   src="http://code.jquery.com/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script> -->


    <script type="text/ruby">puts "Hyperloop JS ok"</script>




  </body>
</html>
